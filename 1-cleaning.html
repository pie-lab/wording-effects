<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Data cleaning</title>

<script src="site_libs/header-attrs-2.20/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/kePrint-0.0.1/kePrint.js"></script>
<link href="site_libs/lightable-0.0.1/lightable.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">On item wording effects</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="1-cleaning.html">Data cleaning</a>
</li>
<li>
  <a href="descriptives.html">Descriptives</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="response_style.html">Does item formatting affect response style?</a>
    </li>
    <li>
      <a href="internal.html">Does item formatting affect internal consistency?</a>
    </li>
    <li>
      <a href="test_retest.html">Does item formatting affect test-retest reliability?</a>
    </li>
    <li>
      <a href="timing_format.html">Does timing differ across format?</a>
    </li>
    <li>
      <a href="device.html">Does device type affect response and timing?</a>
    </li>
    <li>
      <a href="subjective.html">Does item formatting affect participant survey enjoyment?</a>
    </li>
  </ul>
</li>
<li>
  <a href="power.html">Power analysis</a>
</li>
<li>
  <a href="workspace.html">R version and packages</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/pie-lab/wording-effects">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Data cleaning</h1>
<h4 class="date">Last updated 2023-08-10</h4>

</div>


<p>The current section documents the data cleaning process.</p>
<div id="workspace" class="section level2">
<h2>Workspace</h2>
<pre class="r"><code>library(here) # for working with files
library(tidyverse) # for cleaning
library(janitor) # for variable names
library(stringi) # for generating random strings
library(glmmTMB) # for multilevel modeling
library(broom) # for presenting results
library(sjPlot) # for figures
library(ggpubr) # for prettier plots
library(kableExtra) # for nicer tables
library(stringdist) # for scoring memory task
library(papaja) # for pretty numbers
library(psych) # for correlation tests
library(broom.mixed) # for tidying multilevel models</code></pre>
</div>
<div id="change-participant-id-values" class="section level2">
<h2>Change participant ID values</h2>
<p>Before we begin, we create new versions of each data_t1 file that can
be shared for purposes of reproducibility. These data_t1 files do not
include variables that contain potentially identifying meta-data_t1
(e.g., IP address, latitude and longitude). Importantly, we also replace
all Prolific ID values with new, random strings, to prevent the
possibility that these participants are later identified. We also fix an
error that can be introduced through Qualtrics, specifically that all or
parts of the text string “Value will be set from panel or URL” is
sometimes entered into the text box for ID. Prolific ID values are
always 24 characters long and start with a number – we search for
strings that meet this criteria.</p>
<p>(We note that the code chunks in this subsection are turned off in
the RMarkdown file – <code>eval = F</code> – as readers will not be able
to run these chunks.)</p>
<pre class="r"><code># function to load raw file, clean the names, and remove meta-data_t1
# creating a function ensures the same procedure is applied to all
# orginal datasets

load_data = function(path){
  
  full_path = here(path)
  data_obj  = read_rds(path)
  
  data_obj = clean_names(data_obj)
  
  data_obj = data_obj %&gt;%
    select(-end_date,
           -ip_address, 
           -progress, 
           -finished,
           -recorded_date,
           -status,
           -response_id,
           -external_reference, 
           -distribution_channel,
           -user_language,
           -starts_with(&quot;recipient&quot;),
           -starts_with(&quot;location&quot;),
           -starts_with(&quot;meta_info&quot;),
           -prolific_pid)
  
  data_obj = data_obj %&gt;% 
    mutate(proid = str_extract(proid, &quot;\\d([[:alnum:]]{23})&quot;))
  
  return(data_obj)
}

data_t1 &lt;- load_data(&quot;data/data_t1.rds&quot;)
data_2A &lt;- load_data(&quot;data/data_2A.rds&quot;)
data_2B &lt;- load_data(&quot;data/data_2B.rds&quot;)
data_2C &lt;- load_data(&quot;data/data_2C.rds&quot;)
data_2D &lt;- load_data(&quot;data/data_2D.rds&quot;)</code></pre>
</div>
<div id="manually-update-entries" class="section level2">
<h2>Manually update entries</h2>
<p>Several participants notified us of mistaken answers after completing
the survey. We fix those entries here.</p>
<pre class="r"><code>data_t1$sex[data_t1$proid == &quot;63b7d7a4ab0b515649d4f4de&quot;] = &quot;Female&quot;
data_t1$devicetype[data_t1$proid == &quot;60da4f9aa1ced7efeecca18a&quot;] = &quot;Tablet (for example, iPad, Galaxy Tablet, Amazon Fire, etc.)&quot;
data_t1$inaccurate_responses[data_t1$proid == &quot;60da4f9aa1ced7efeecca18a&quot;] = &quot;No&quot;</code></pre>
</div>
<div id="deidentify-data-only-run-after-data-collection-is-complete"
class="section level2">
<h2>Deidentify data – only run after data collection is complete</h2>
<p>We identify all unique participant IDs. For each, we generate a new
string, Then we replace the original ID values with the new strings.</p>
<pre class="r"><code>original_id &lt;- unique(c(data_t1$proid,
                       data_2A$proid,
                       data_2B$proid,
                       data_2C$proid,
                       data_2D$proid))

#remove missing values -- represent bots or tests
original_id = original_id[!is.na(original_id)]

#generate new ids (randoms tring of letters and numbers)
set.seed(202108)
new_id &lt;- stri_rand_strings(n = length(original_id), length = 24)

#replace old string with new string
for(i in 1:length(original_id)){
  data_t1$proid[data_t1$proid == original_id[i]] &lt;- new_id[i]
  data_2A$proid[data_2A$proid == original_id[i]] &lt;- new_id[i]
  data_2B$proid[data_2B$proid == original_id[i]] &lt;- new_id[i]
  data_2C$proid[data_2C$proid == original_id[i]] &lt;- new_id[i]
  data_2D$proid[data_2D$proid == original_id[i]] &lt;- new_id[i]
}</code></pre>
<p>We end by saving each data_t1 frame as new .csv files, to be uploaded
to OSF and shared for reproduction.</p>
<pre class="r"><code>write_csv(data_t1, file = here(&quot;deidentified data/data_time1.csv&quot;))
write_csv(data_2A, file = here(&quot;deidentified data/data_time2_A.csv&quot;))
write_csv(data_2B, file = here(&quot;deidentified data/data_time2_B.csv&quot;))
write_csv(data_2C, file = here(&quot;deidentified data/data_time2_C.csv&quot;))
write_csv(data_2D, file = here(&quot;deidentified data/data_time2_D.csv&quot;))</code></pre>
<pre class="r"><code>data_t1 &lt;- read_csv(here(&quot;deidentified data/data_time1.csv&quot;))
data_2A &lt;- read_csv(here(&quot;deidentified data/data_time2_A.csv&quot;))
data_2B &lt;- read_csv(here(&quot;deidentified data/data_time2_B.csv&quot;))
data_2C &lt;- read_csv(here(&quot;deidentified data/data_time2_C.csv&quot;))
data_2D &lt;- read_csv(here(&quot;deidentified data/data_time2_D.csv&quot;))</code></pre>
</div>
<div id="time-1" class="section level2">
<h2>Time 1</h2>
<p>We rename several columns, in order to facilitate the use of regular
expressions later. Specifically, we remove the underscores (_) in the
columns pertaining to broad-mindedness and self-disciplined.</p>
<pre class="r"><code>names(data_t1) = str_replace(names(data_t1), &quot;broad_mind&quot;, &quot;broadmind&quot;)
names(data_t1) = str_replace(names(data_t1), &quot;self_disciplind&quot;, &quot;selfdisciplined&quot;)</code></pre>
<p>We can also remove the meta-data (timing, etc) around two attention
check adjectives, “human” and “asleep”.</p>
<pre class="r"><code>data_t1 = data_t1 %&gt;% 
  select(-starts_with(&quot;t_human&quot;),
         -starts_with(&quot;t_asleep&quot;))</code></pre>
<div id="recode-personality-item-responses-to-numeric"
class="section level3">
<h3>Recode personality item responses to numeric</h3>
<p>We recode the responses to personality items, which we downloaded as
text strings. We chose to use text strings as opposed to numbers to
avoid any possibility that the Qualtrics-set coding was incorrect. We
start this process by identifying the personality items
(<code>p_items</code>) using regular expressions. All personality items
take a format like <code>outgoing_a</code> or <code>helpful_b_2</code>;
that is, they start with the adjective, followed by a letter indicating
with which condition or item format the adjective was presented, and
sometimes they are followed by a 2, indicating it was the second time
the participant saw the adjective. We can represent this pattern using
regular expressions.</p>
<pre class="r"><code>p_items = str_extract(names(data_t1), &quot;^[[:alpha:]]*_[abcd](_2)?$&quot;)
p_items = p_items[!is.na(p_items)]

personality_items = select(data_t1, proid, all_of(p_items))</code></pre>
<p>Next, we write a simple function to recode values. We find the
<code>case_when</code> function to be the most clear method of
communicating the recoding process when moving from string to
numeric.</p>
<pre class="r"><code>recode_p = function(x){
  y = case_when(
    x == &quot;Very inaccurate&quot; ~ 1,
    x == &quot;Moderately inaccurate&quot; ~ 2,
    x == &quot;Slightly inaccurate&quot; ~ 3,
    x == &quot;Slightly accurate&quot; ~ 4,
    x == &quot;Moderately accurate&quot; ~ 5,
    x == &quot;Very accurate&quot; ~ 6,
    TRUE ~ NA_real_)
  return(y)
}</code></pre>
<p>Finally, we apply this function to all personality items.</p>
<pre class="r"><code>personality_items = personality_items %&gt;%
  # apply to all variables except proid
  mutate(across(!c(proid), recode_p))</code></pre>
<p>Now we merge the recoded values back into the data_t1.</p>
<pre class="r"><code># remove personality items from data file
data_t1 = select(data_t1, -all_of(p_items))
# merge in recoded personality items
data_t1 = full_join(data_t1, personality_items)</code></pre>
</div>
<div id="drop-bots-and-inattentive-participants" class="section level3">
<h3>Drop bots and inattentive participants</h3>
<div id="based-on-id" class="section level4">
<h4>Based on ID</h4>
<p>Recall that when preparing the data files for sharing, we replaced
all Prolific IDs with random strings. A consequence of this cleaning is
that any ID entered that did not have a string meeting the Prolific ID
format requirements (24 character, starting with a number) was replaced
with <code>NA</code>. To remove these bots, we can simply filter out
missing ID values.</p>
<p>We removed 0 participants without valid Prolific IDs. (This likely
occurred based on sharing of the survey link among Prolific users.)</p>
</div>
<div id="based-on-language" class="section level4">
<h4>Based on language</h4>
<pre class="r"><code>data_t1 = data_t1 %&gt;%
  filter(english %in% c(&quot;Well&quot;, &quot;Very well (fluent/native)&quot;))</code></pre>
<p>We removed 1 participants that do not speak english well or very
well.</p>
</div>
<div id="based-on-inattentive-responding" class="section level4">
<h4>Based on inattentive responding</h4>
<p>We expect to exclude any participant who has an average response of 4
(“slightly agree”) or greater to the attention check items. Two items
from the Inattentive and Deviant Responding Inventory for Adjectives
(IDRIA) scale (Kay &amp; Saucier, in prep) have been included here, in
part to help evaluate the extent of inattentive responding but also to
consider the effect of item wording on these items. The two items used
here (i.e., “Asleep”, “Human”) were chosen to be as inconspicuous as
possible, so as to not to inflate item response duration. The frequency
item (i.e., “human”) will be reverse-scored, so that higher scores on
both the infrequency and frequency items reflect greater inattentive
responding. Figure @ref(fig:1-cleaning-27) shows the distribution of
average responses to attention check items.</p>
<pre class="r"><code>in_average = data_t1 %&gt;%
  # reverse score human
  mutate(across(matches(&quot;^human&quot;),  ~(.x*-1)+7)) %&gt;%
  # select id and attention check items
  select(proid, matches(&quot;^human&quot;), matches(&quot;^asleep&quot;)) %&gt;% 
  gather(item, response, -proid) %&gt;%
  filter(!is.na(response)) %&gt;%
  group_by(proid) %&gt;%
  summarise(avg = mean(response)) %&gt;%
  mutate(
    remove = case_when(
      avg &gt;= 4 ~ &quot;Remove&quot;,
      TRUE ~ &quot;Keep&quot;))</code></pre>
<div class="figure">
<img src="1-cleaning_files/figure-html/1-cleaning-27-1.png" alt="Average response to inattention check items" width="672" />
<p class="caption">
Average response to inattention check items
</p>
</div>
<p>We remove 8 participants whose responses suggest inattention.</p>
<pre class="r"><code>data_t1 = data_t1 %&gt;%
  full_join(select(in_average, proid, remove)) %&gt;%
  filter(remove != &quot;Remove&quot;) %&gt;%
  select(-remove)</code></pre>
</div>
<div id="based-on-patterns" class="section level4">
<h4>Based on patterns</h4>
<p>We remove any participant who provides the same response to over half
of the items (21 or more items) from a given block in a row.</p>
<p>To proceed, first we create a data frame containing just the
responses to personality items in the first block.</p>
<pre class="r"><code># first, identify unique adjectives, in order
adjectives = p_items %&gt;%
  str_remove_all(&quot;_.&quot;) %&gt;%
  unique()

# extract block 1 questions using regular expressions
# these follow the personality item format described above, but never end with 2
block1 = data_t1 %&gt;%
  select(proid, matches(&quot;^[[:alpha:]]+_[abcd]$&quot;)) </code></pre>
<p>Next, we rename the variables. Instead of variable names identifying
the specific adjective (e.g., outgoing_a), we need variable names which
indicate the order in which the adjective was seen by the participant
(e.g., trait01_a). This will help us determine patterns by item order,
rather than adjective content. Participants all saw adjectives in the
same order (i.e., all participants, regardless of condition, saw
outgoing first).</p>
<pre class="r"><code>#rename variables 
n = 0
for(i in adjectives){ # for each adjective
  n = n+1 # identify its location in the presentation
  names(block1) = str_replace(names(block1), #in variable names
                              # replace the adjective string
                              i, 
                              # with the word trait followed by its place
                              paste0(&quot;trait&quot;, str_pad(n, 2, pad = &quot;0&quot;)))
}</code></pre>
<p>We use <code>gather</code> and <code>spread</code> to quickly combine
columns measuring the same trait. That is, instead of having columns
trait01_a, trait01_b, trait01_c, and trait01_d, we now have a single
column called trait01.</p>
<pre class="r"><code>block1 = block1 %&gt;%
  gather(item, response, -proid) %&gt;%
  filter(!is.na(response)) %&gt;%
  separate(item, into = c(&quot;item&quot;, &quot;format&quot;)) %&gt;%
  select(-format) %&gt;%
  spread(item, response)</code></pre>
<p>To count the number of runs, we loop through participants and, within
participant, loop through columns. Within participant, we create an
object called <code>run</code>. If a response to a personality item is
the same as the participant’s response to the previous item, we increase
the value of <code>run</code> by 1. If this new value is the largest
<code>run</code> value for that participant, it becomes the value of an
object called <code>maxrun</code>. If the participant gives a new
response, <code>run</code> is reset to 0. We record the
<code>maxrun</code> value for each partipant in a variable called
<code>block1_runs</code>.</p>
<pre class="r"><code>block1_runs = numeric(length = nrow(block1))


for(i in 1:nrow(block1)){
  run = 0
  maxrun = 0
  for(j in 3:ncol(block1)){
    if(block1[i,j] == block1[i, j-1]){
      run = run+1
      if(run &gt; maxrun) maxrun = run
      } else{ run = 0}
  } 
  block1_runs[i] = maxrun
}

#add to data_t1 frame
block1$block1_runs = block1_runs</code></pre>
<p>Here we repeat the process described above with Block 2 data.</p>
<pre class="r"><code># extract block 2 questions
block2 = data_t1 %&gt;%
  select(proid, matches(&quot;^[[:alpha:]]+_[abcd]_2$&quot;)) 

#rename variables 
n = 0
for(i in adjectives){
  n = n+1
  names(block2) = str_replace(names(block2), i, paste0(&quot;trait&quot;, str_pad(n, 2, pad = &quot;0&quot;)))
}

block2 = block2 %&gt;%
  gather(item, response, -proid) %&gt;%
  filter(!is.na(response)) %&gt;%
  mutate(item = str_remove(item, &quot;_2&quot;)) %&gt;%
  separate(item, into = c(&quot;item&quot;, &quot;format&quot;)) %&gt;%
  select(-format) %&gt;%
  spread(item, response)

block2_runs = numeric(length = nrow(block2))

#identify max run for each participant
for(i in 1:nrow(block2)){
  run = 0
  maxrun = 0
  for(j in 3:ncol(block2)){
    if(block2[i,j] == block2[i, j-1]){
      run = run+1
      if(run &gt; maxrun) maxrun = run
      } else{ run = 0}
  } 
  block2_runs[i] = maxrun
}

#add to data_t1 frame
block2$block2_runs = block2_runs</code></pre>
<p>We combine the variables holding the maximum runs into a single data
frame. We will remove participants if their maximum run in either block
was greater than or equal to 21. See Figure @ref(fig:1-cleaning-24) for
a visualization of the spread and associations between run lengths
across participants.</p>
<pre class="r"><code>#combine results
runs_data = block1 %&gt;%
  select(proid, block1_runs) %&gt;%
  full_join(select(block2, proid, block2_runs)) %&gt;%
  mutate(
    remove = case_when(
      block1_runs &gt;= 21 ~ &quot;Remove&quot;,
      block2_runs &gt;= 21 ~ &quot;Remove&quot;,
      TRUE ~ &quot;Keep&quot;
    ))</code></pre>
<div class="figure">
<img src="1-cleaning_files/figure-html/1-cleaning-24-1.png" alt="Maximum number of same consecutive responses in personality blocks." width="672" />
<p class="caption">
Maximum number of same consecutive responses in personality blocks.
</p>
</div>
<p>There were 5 participants who provided the same answer 21 or more
times in a row. These participants were removed from the analyses.</p>
<pre class="r"><code>data_t1 = data_t1 %&gt;%
  full_join(select(runs_data, proid, remove)) %&gt;%
  filter(remove != &quot;Remove&quot;) %&gt;%
  select(-remove)

rm(runs_data)</code></pre>
</div>
<div id="based-on-average-time-to-respond-to-personality-items"
class="section level4">
<h4>Based on average time to respond to personality items</h4>
<p>First, select just the timing of the personality items. We do this by
searching for specific strings: “t_[someword]<em>[a or b or c or
d]</em>(maybe 2_)_page_submit.”</p>
<pre class="r"><code>timing_data = data_t1 %&gt;%
  select(proid, matches(&quot;t_[[:alpha:]]*_[abcd](_2)?_page_submit&quot;))</code></pre>
<p>Next we gather into long form and remove missing timing values</p>
<pre class="r"><code>timing_data = timing_data %&gt;%
  gather(variable, timing, -proid) %&gt;%
  filter(!is.na(timing))</code></pre>
<p>To check, each participant should have the same number of responses:
76.</p>
<pre class="r"><code>timing_data %&gt;%
  group_by(proid) %&gt;%
  count() %&gt;%
  ungroup() %&gt;% 
  summarise(min(n), max(n))</code></pre>
<pre><code>## # A tibble: 1 × 2
##   `min(n)` `max(n)`
##      &lt;int&gt;    &lt;int&gt;
## 1       76       76</code></pre>
<p>Excellent! Now we calculate the average response time per item for
each participant. We mark a participant for removal if their average
time is less than 1 second or greater than 30. See Figure
@ref(fig:1-cleaning-33) for a distribution of average response time.</p>
<pre class="r"><code>timing_data = timing_data %&gt;%
  group_by(proid) %&gt;%
  summarise(m_time = mean(timing)) %&gt;%
  mutate(remove = case_when(
    m_time &lt; 1 ~ &quot;Remove&quot;,
    m_time &gt; 30 ~ &quot;Remove&quot;,
    TRUE ~ &quot;Keep&quot;
  ))</code></pre>
<div class="figure">
<img src="1-cleaning_files/figure-html/1-cleaning-33-1.png" alt="Distribution of average time to respond to personality items." width="672" />
<p class="caption">
Distribution of average time to respond to personality items.
</p>
</div>
<pre class="r"><code>data_t1 = inner_join(data_t1, filter(timing_data, remove == &quot;Keep&quot;)) %&gt;%
  select(-remove)</code></pre>
<p>Based on timing, we removed 9 participants.</p>
<p>We create a variable which indicates the Block 1 condition of each
participant. This is used in two places: first, in recruiting
participants at Time 2 (participants are given the same format at Time 2
as they received in Block 1), and second, in selecting the corret items
during the test-retest analyses.</p>
<pre class="r"><code>data_t1 = data_t1 %&gt;% 
  mutate(condition = case_when(
    !is.na(outgoing_a) ~ &quot;A&quot;,
    !is.na(outgoing_b) ~ &quot;B&quot;,
    !is.na(outgoing_c) ~ &quot;C&quot;,
    !is.na(outgoing_d) ~ &quot;D&quot;,
  ))</code></pre>
<p>At this point, we’ll extract the Prolific ID numbers. These
participants will be eligible to take the survey at Time 2.</p>
<pre class="r"><code>data_t1 %&gt;% 
  select(proid, condition) %&gt;% 
  write_csv(file = here(&quot;data/elligible_proid.csv&quot;))</code></pre>
</div>
</div>
</div>
<div id="time-2" class="section level2">
<h2>Time 2</h2>
<pre class="r"><code>data_2 = data_2A %&gt;% 
  dplyr::full_join(data_2B) %&gt;% 
  dplyr::full_join(data_2C) %&gt;% 
  dplyr::full_join(data_2D)</code></pre>
<p>Rename the following columns.</p>
<pre class="r"><code>data_2 = data_2 %&gt;%
  rename(start_date2 = start_date,
         duration_in_seconds2 = duration_in_seconds)</code></pre>
<p>We rename several columns, in order to facilitate the use of regular
expressions later. Specifically, we remove the underscores (_) in the
columns pertaining to broad-mindedness and self-disciplined.</p>
<pre class="r"><code>names(data_2) = str_replace(names(data_2), &quot;broad_mind&quot;, &quot;broadmind&quot;)
names(data_2) = str_replace(names(data_2), &quot;self_disciplind&quot;, &quot;selfdisciplined&quot;)</code></pre>
<p>We can also remove the meta-data (timing, etc) around two attention
check adjectives, “human” and “asleep”.</p>
<pre class="r"><code>data_2 = data_2 %&gt;% 
  select(-starts_with(&quot;t_human&quot;),
         -starts_with(&quot;t_asleep&quot;))</code></pre>
<div id="recode-personality-item-responses-to-numeric-1"
class="section level3">
<h3>Recode personality item responses to numeric</h3>
<p>We recode the responses to personality items, which we downloaded as
text strings. Here, all items end with <code>_3</code> and sometimes
with <code>i</code>.</p>
<pre class="r"><code>p_items_2 = str_extract(names(data_2), &quot;^[[:alpha:]]*_[abcd]_3(i)?$&quot;)
p_items_2 = p_items_2[!is.na(p_items_2)]

personality_items_2 = select(data_2, proid, all_of(p_items_2))</code></pre>
<p>We apply the recoding function to all personality items.</p>
<pre class="r"><code>personality_items_2 = personality_items_2 %&gt;%
  mutate(
    across(!c(proid), recode_p))</code></pre>
<p>Now we merge this back into the data_2.</p>
<pre class="r"><code>data_2 = select(data_2, -all_of(p_items_2))
data_2 = full_join(data_2, personality_items_2)</code></pre>
</div>
<div id="drop-bots-and-inattentive-participants-1"
class="section level3">
<h3>Drop bots and inattentive participants</h3>
<p>This code recreates the steps outlined in detail above for Time 1.
Please refer to the descriptions above for justification and
explaination of the code presented here.</p>
<div id="based-on-id-1" class="section level4">
<h4>Based on ID</h4>
<p>We also check that the ID in time 2 matches an ID in time 1.</p>
<pre class="r"><code>data_2 = data_2 %&gt;% 
  filter(proid %in% data_t1$proid)</code></pre>
<p>We removed 2 participants without valid Prolific IDs.</p>
</div>
<div id="based-on-inattentive-responding-1" class="section level4">
<h4>Based on inattentive responding</h4>
<p>Participants who respond positively to the adjective <em>asleep</em>
or negatively to the word <em>human</em> are assumed to be inattentive.
We filter out participants whose average response to these two items is
greater than or equal to 4 (see Figure @ref(fig:1-cleaning-59) for the
distribution).</p>
<pre class="r"><code>in_average = data_2 %&gt;%
  # reverse score human
  mutate(across(matches(&quot;^human&quot;),  ~(.x*-1)+7)) %&gt;%
  # select id and attention check items
  select(proid, matches(&quot;^human&quot;), matches(&quot;^asleep&quot;)) %&gt;% 
  gather(item, response, -proid) %&gt;%
  filter(!is.na(response)) %&gt;%
  group_by(proid) %&gt;%
  summarise(avg = mean(response)) %&gt;%
  mutate(
    remove = case_when(
      avg &gt;= 4 ~ &quot;Remove&quot;,
      TRUE ~ &quot;Keep&quot;))</code></pre>
<div class="figure">
<img src="1-cleaning_files/figure-html/1-cleaning-59-1.png" alt="Average response to inattention check items" width="672" />
<p class="caption">
Average response to inattention check items
</p>
</div>
<p>We remove 7 participants whose responses suggest inattention.</p>
<pre class="r"><code>data_2 = data_2 %&gt;%
  full_join(select(in_average, proid, remove)) %&gt;%
  filter(remove != &quot;Remove&quot;) %&gt;%
  select(-remove)</code></pre>
</div>
<div id="based-on-patterns-1" class="section level4">
<h4>Based on patterns</h4>
<p>We remove any participant who provides the same response to over half
of the items (21 or more items) from a given block in a row. The
distribution of runs in Time 2 is depicted in Figure
@ref(fig:1-cleaning-55).</p>
<pre class="r"><code># first, identify unique adjectives, in order
adjectives = p_items_2 %&gt;%
  str_remove_all(&quot;_.&quot;) %&gt;%
  unique()

# extract block 3 questions
block3 = data_2 %&gt;%
  select(proid, all_of(p_items_2)) 

#rename variables 
n = 0
for(i in adjectives){
  n = n+1
  names(block3) = str_replace(names(block3), i, paste0(&quot;trait&quot;, str_pad(n, 2, pad = &quot;0&quot;)))
}


block3 = block3 %&gt;%
  gather(item, response, -proid) %&gt;%
  filter(!is.na(response)) %&gt;%
  mutate(item = str_remove(item, &quot;_3(i)?$&quot;)) %&gt;% 
  separate(item, into = c(&quot;item&quot;, &quot;format&quot;)) %&gt;% 
  select(-format) %&gt;%
  spread(item, response)

block3_runs = numeric(length = nrow(block3))

for(i in 1:nrow(block3)){
  run = 0
  maxrun = 0
  for(j in 3:ncol(block3)){
    if(block3[i,j] == block3[i, j-1]){
      run = run+1
      if(run &gt; maxrun) maxrun = run
      } else{ run = 0}
  } 
  block3_runs[i] = maxrun
}

#add to data_2 frame
block3$block3_runs = block3_runs</code></pre>
<pre class="r"><code>#combine results
runs_data_2 = block3 %&gt;%
  select(proid, block3_runs) %&gt;%
  mutate(
    remove = case_when(
      block3_runs &gt;= 21 ~ &quot;Remove&quot;,
      TRUE ~ &quot;Keep&quot;
    ))</code></pre>
<div class="figure">
<img src="1-cleaning_files/figure-html/1-cleaning-55-1.png" alt="Maximum number of same consecutive responses in personality block 3." width="672" />
<p class="caption">
Maximum number of same consecutive responses in personality block 3.
</p>
</div>
<p>There were 0 participants who provided the same answer 21 or more
times in a row. These participants were removed from the analyses.</p>
<pre class="r"><code>data_2 = data_2 %&gt;%
  full_join(select(runs_data_2, proid, remove)) %&gt;%
  filter(remove != &quot;Remove&quot;) %&gt;%
  select(-remove)

rm(runs_data_2)</code></pre>
</div>
<div id="based-on-average-time-to-respond-to-personality-items-1"
class="section level4">
<h4>Based on average time to respond to personality items</h4>
<p>Participants who take too little (&lt; 1 second) or too long (greater
than 30 seconds) on average to answer each personality item are
excluded. See Figure @ref(fig:1-cleaning-64) for the distribution of
average response time per item.</p>
<pre class="r"><code>timing_data_2 = data_2 %&gt;%
  select(proid, matches(&quot;t_[[:alpha:]]*_[abcd]_3(i)?_page_submit&quot;))

timing_data_2 = timing_data_2 %&gt;%
  gather(variable, timing, -proid) %&gt;%
  filter(!is.na(timing))</code></pre>
<p>To check, each participant should have the same number of responses:
33.</p>
<pre class="r"><code>timing_data_2 %&gt;%
  group_by(proid) %&gt;%
  count() %&gt;%
  ungroup() %&gt;% 
  summarise(min(n), max(n))</code></pre>
<pre><code>## # A tibble: 1 × 2
##   `min(n)` `max(n)`
##      &lt;int&gt;    &lt;int&gt;
## 1       37       38</code></pre>
<pre class="r"><code>timing_data_2 = timing_data_2 %&gt;%
  group_by(proid) %&gt;%
  summarise(m_time = mean(timing)) %&gt;%
  mutate(remove = case_when(
    m_time &lt; 1 ~ &quot;Remove&quot;,
    m_time &gt; 30 ~ &quot;Remove&quot;,
    TRUE ~ &quot;Keep&quot;
  ))</code></pre>
<div class="figure">
<img src="1-cleaning_files/figure-html/1-cleaning-64-1.png" alt="Distribution of average time to respond to personality items in Block 3." width="672" />
<p class="caption">
Distribution of average time to respond to personality items in Block 3.
</p>
</div>
<pre class="r"><code>data_2 = inner_join(data_2, filter(timing_data_2, remove == &quot;Keep&quot;)) %&gt;%
  select(-remove)</code></pre>
<p>Based on timing, we removed 8 participants.</p>
</div>
</div>
<div id="merge-all-datasets-together" class="section level3">
<h3>Merge all datasets together</h3>
<p>We merge the Time 1 and Time 2 datasets together here.</p>
<pre class="r"><code>data_2 = data_2 %&gt;% 
  select(proid, start_date2, duration_in_seconds2, very_delayed_recall, contains(&quot;_3&quot;)) %&gt;% 
  mutate(time2 = &quot;yes&quot;) #indicates participant in time 2

data = data_t1 %&gt;% full_join(data_2)</code></pre>
</div>
</div>
<div id="all-data" class="section level2">
<h2>All data</h2>
<div id="reverse-score-personality-items" class="section level3">
<h3>Reverse score personality items</h3>
<p>The following items are (typically) negatively correlated with the
others: reckless, moody, worrying, nervous, careless, impulsive. We
reverse-score them to ease interpretation of associations and means in
the later sections. In short, all traits will be scored such that larger
numbers are indicative of the more socially desirable end of the
spectrum.</p>
<pre class="r"><code>data = data %&gt;%
  mutate(
    across(matches(&quot;^reckless&quot;),       ~(.x*-1)+7),
    across(matches(&quot;^moody&quot;),          ~(.x*-1)+7),
    across(matches(&quot;^worrying&quot;),       ~(.x*-1)+7),
    across(matches(&quot;^nervous&quot;),        ~(.x*-1)+7),
    across(matches(&quot;^careless&quot;),       ~(.x*-1)+7),
    across(matches(&quot;^impulsive&quot;),      ~(.x*-1)+7),
    across(matches(&quot;^quiet&quot;),          ~(.x*-1)+7),
    across(matches(&quot;^unsympathetic&quot;),  ~(.x*-1)+7),
    across(matches(&quot;^uncreative&quot;),     ~(.x*-1)+7),
    across(matches(&quot;^shy&quot;),            ~(.x*-1)+7),
    across(matches(&quot;^cold&quot;),           ~(.x*-1)+7),
    across(matches(&quot;^unintellectual&quot;), ~(.x*-1)+7))</code></pre>
<p>We also create a vector noting the items that are reverse scored. We
use this later in tables, to help identify patterns when looking at
analyses within-adjective. We use this object elsewhere in the
analyses.</p>
<pre class="r"><code>reverse = c(&quot;reckless&quot;, &quot;moody&quot;, &quot;worrying&quot;, &quot;nervous&quot;, &quot;careless&quot;, &quot;impulsive&quot;)</code></pre>
</div>
<div id="score-memory-task" class="section level3">
<h3>Score memory task</h3>
<p>Now we score the memory task. We start by creating vectors of the
correct responses.</p>
<pre class="r"><code>correct1 = c(&quot;book&quot;, &quot;child&quot;, &quot;gold&quot;, &quot;hotel&quot;, &quot;king&quot;, 
             &quot;market&quot;, &quot;paper&quot;, &quot;river&quot;, &quot;skin&quot;, &quot;tree&quot;)

correct2 = c(&quot;butter&quot;, &quot;college&quot;, &quot;dollar&quot;, &quot;earth&quot;, &quot;flag&quot;, 
             &quot;home&quot;, &quot;machine&quot;, &quot;ocean&quot;, &quot;sky&quot;, &quot;wife&quot;)

correct3 = c(&quot;blood&quot;, &quot;corner&quot;, &quot;engine&quot;, &quot;girl&quot;, &quot;house&quot;, 
             &quot;letter&quot;, &quot;rock&quot;, &quot;shoes&quot;, &quot;valley&quot;, &quot;woman&quot;)

correct4 = c(&quot;baby&quot;, &quot;church&quot;, &quot;doctor&quot;, &quot;fire&quot;, &quot;garden&quot;, 
             &quot;palace&quot;, &quot;sea&quot;, &quot;table&quot;, &quot;village&quot;, &quot;water&quot;)</code></pre>
<p>Next we convert all responses to lowercase. Then we break the string
of responses into a vector containing many strings.</p>
<pre class="r"><code>data = data %&gt;%
  mutate(
    across(matches(&quot;recall&quot;),tolower), # convert to lower
    #replace carriage return with space
    across(matches(&quot;recall&quot;), 
           \(x) str_replace_all(x, pattern = &quot;\\n&quot;, replacement = &quot;,&quot;)),
    # remove spaces
    across(matches(&quot;recall&quot;), 
           \(x) str_replace_all(x, pattern = &quot; &quot;, replacement = &quot;,&quot;)),
    # remove doubles
    across(matches(&quot;recall&quot;), 
           \(x) str_replace_all(x, pattern = &quot;,,&quot;, replacement = &quot;,&quot;)),
    #remove last comma
    across(matches(&quot;recall&quot;), 
           \(x) str_remove(x, pattern = &quot;,$&quot;)),
    # split the strings based on the spaces
    across(matches(&quot;recall&quot;), 
           \(x) str_split(x, pattern = &quot;,&quot;)))</code></pre>
<div id="immediate-recall" class="section level4">
<h4>Immediate recall</h4>
<p>Now we use the <code>amatch</code> function in the
<code>stringdist</code> package to look for exact (or close) matches to
the target words. This function returns for each word either the
position of the key in which you can find the target word or
<code>NA</code> to indicate the word or a close match does not exist in
the string.</p>
<pre class="r"><code>distance = 1 #maximum distance between target word and correct response
data = data %&gt;%
  mutate(
    memory1 = map(recall1, ~sapply(., amatch, correct1, maxDist = distance)),
    memory2 = map(recall2, ~sapply(., amatch, correct2, maxDist = distance)),
    memory3 = map(recall3, ~sapply(., amatch, correct3, maxDist = distance)),
    memory4 = map(recall4, ~sapply(., amatch, correct4, maxDist = distance))
    )</code></pre>
<p>We count the number of correct answers. This gets complicated; in
lieu of writing out a paragraph explanation, we have opted for in-text
comments to orient those interested in following the code.</p>
<pre class="r"><code>data = data %&gt;%
  mutate(
    across(starts_with(&quot;memory&quot;),
      #replace position with 1
      ~map(., sapply, FUN = function(x) ifelse(x &gt;0, 1, 0))),
    across(starts_with(&quot;recall&quot;),
           # are there non-missing values in the original response?
           ~map_dbl(., 
                    .f = function(x) sum(!is.na(x))), 
           .names = &quot;{.col}_miss&quot;),
    across(starts_with(&quot;memory&quot;),
      #replace position with 1
      # count the number of correct answers
      ~map_dbl(., sum, na.rm=T))) %&gt;%
  mutate(
    memory1 = case_when(
      # if there were no responses, make the answer NA
      recall1_miss == 0 ~ NA_real_,
      # otherwise, the number of correct guesses
      TRUE ~ memory1),
    memory2 = case_when(
      recall2_miss == 0 ~ NA_real_,
      TRUE ~ memory2),
    memory3 = case_when(
      recall3_miss == 0 ~ NA_real_,
      TRUE ~ memory3),
    memory4 = case_when(
      recall4_miss == 0 ~ NA_real_,
      TRUE ~ memory4)) %&gt;%
  # no longer need the missing count variables
  select(-ends_with(&quot;miss&quot;))</code></pre>
<p>Finally, we want to go from 4 columns (one for each recall test), to
two: one that has the number of correct responses, and one that
indicates which version they saw.</p>
<pre class="r"><code>data = data %&gt;%
  select(proid, starts_with(&quot;memory&quot;)) %&gt;%
  gather(mem_condition, memory, -proid) %&gt;%
  filter(!is.na(memory)) %&gt;%
  mutate(mem_condition = str_remove(mem_condition, &quot;memory&quot;)) %&gt;%
  full_join(data)</code></pre>
<p>To demonstrate the accuracy of the code, here we present a random
subset of participants’ raw responses and their assigned memory
score.</p>
<pre class="r"><code>#from memory condition 1
data %&gt;% 
  filter(mem_condition == 1) %&gt;% 
  select(recall1, memory) %&gt;% 
  sample_n(3) %&gt;% 
  mutate(recall1 = map_chr(recall1, paste, collapse = &quot;, &quot;))</code></pre>
<pre><code>## # A tibble: 3 × 2
##   recall1                                            memory
##   &lt;chr&gt;                                               &lt;dbl&gt;
## 1 book, boy                                               1
## 2 book, child, gold, hotel, tree                          5
## 3 tree, river, skin, king, hotel, child, paper, book      8</code></pre>
<pre class="r"><code>#from memory condition 2
data %&gt;% 
  filter(mem_condition == 2) %&gt;% 
  select(recall2, memory) %&gt;% 
  sample_n(3) %&gt;% 
  mutate(recall2 = map_chr(recall2, paste, collapse = &quot;, &quot;))</code></pre>
<pre><code>## # A tibble: 3 × 2
##   recall2                                    memory
##   &lt;chr&gt;                                       &lt;dbl&gt;
## 1 butter, college, human, earth, dollar, sky      5
## 2 college, wife                                   2
## 3 butter, flag, sky, machine                      4</code></pre>
<pre class="r"><code>#from memory condition 3
data %&gt;% 
  filter(mem_condition == 3) %&gt;% 
  select(recall3, memory) %&gt;% 
  sample_n(3) %&gt;% 
  mutate(recall3 = map_chr(recall3, paste, collapse = &quot;, &quot;))</code></pre>
<pre><code>## # A tibble: 3 × 2
##   recall3                                                         memory
##   &lt;chr&gt;                                                            &lt;dbl&gt;
## 1 blood, corner, engine, girl, house, letter, rock, shoes, valley      9
## 2 blood, engine, house, girl, rock, shoes, woman                       7
## 3 blood, rock, corner, valley, shoes, woman, girl                      7</code></pre>
<pre class="r"><code>#from memory condition 4
data %&gt;% 
  filter(mem_condition == 4) %&gt;% 
  select(recall4, memory) %&gt;% 
  sample_n(3) %&gt;% 
  mutate(recall4 = map_chr(recall4, paste, collapse = &quot;, &quot;))</code></pre>
<pre><code>## # A tibble: 3 × 2
##   recall4                                                          memory
##   &lt;chr&gt;                                                             &lt;dbl&gt;
## 1 baby, church, doctor, table, palace, garden, water, sea, village      9
## 2 baby, church, doctor, palace, sea, garden, ocean, table, village      8
## 3 baby, church, fire, doctor, palace, water                             6</code></pre>
<p>Participants remember on average 6.76 words correctly <span
class="math inline">\((SD = 1.96)\)</span>.</p>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>
Memory responses by condition
</caption>
<thead>
<tr>
<th style="text-align:left;">
Condition
</th>
<th style="text-align:right;">
Mean
</th>
<th style="text-align:right;">
SD
</th>
<th style="text-align:right;">
Min
</th>
<th style="text-align:right;">
Max
</th>
<th style="text-align:right;">
N
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
1
</td>
<td style="text-align:right;">
6.84
</td>
<td style="text-align:right;">
2.05
</td>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
245
</td>
</tr>
<tr>
<td style="text-align:left;">
2
</td>
<td style="text-align:right;">
6.42
</td>
<td style="text-align:right;">
1.87
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
241
</td>
</tr>
<tr>
<td style="text-align:left;">
3
</td>
<td style="text-align:right;">
6.78
</td>
<td style="text-align:right;">
2.03
</td>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
245
</td>
</tr>
<tr>
<td style="text-align:left;">
4
</td>
<td style="text-align:right;">
7.00
</td>
<td style="text-align:right;">
1.85
</td>
<td style="text-align:right;">
2
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
244
</td>
</tr>
</tbody>
</table>
</div>
<div id="delayed-recall" class="section level4">
<h4>Delayed recall</h4>
<p>A challenge with the delayed recall task is identifying the memory
condition that participants were assigned to, but this is made easier by
the work done above. The following code mainly reproduces the steps used
for scoring the immediate memory recall task. The main difference is
that we have a single column containing all responses
(<code>delayed_recall</code>), regardless of which memory condition
participants were assigned to. We score this response against all four
answer keys, then select the maximum (best) score.</p>
<pre class="r"><code>mem2 = data %&gt;%
  select(proid, mem_condition, delayed_recall) %&gt;%
  mutate(newid = 1:nrow(.))

mem2 = mem2 %&gt;%
  mutate(
    delayed_recall1 = map(delayed_recall, ~sapply(., amatch, correct1, maxDist = distance)),
    delayed_recall2 = map(delayed_recall, ~sapply(., amatch, correct2, maxDist = distance)),
    delayed_recall3 = map(delayed_recall, ~sapply(., amatch, correct3, maxDist = distance)),
    delayed_recall4 = map(delayed_recall, ~sapply(., amatch, correct4, maxDist = distance))
    ) %&gt;%
  gather(variable, delayed_memory, delayed_recall1:delayed_recall4)

mem2 = mem2 %&gt;%
  mutate(
      delayed_memory = map(delayed_memory, sapply, 
                  FUN = function(x) ifelse(x &gt;0, 1, 0)),
      # count the number of correct answers
      delayed_memory = map_dbl(delayed_memory, sum, na.rm=T))

mem2 = mem2 %&gt;%
  group_by(proid) %&gt;%
  filter(delayed_memory == max(delayed_memory)) %&gt;%
  filter(row_number() == 1 ) %&gt;% 
  select(-delayed_recall, -variable, -newid)

data = inner_join(data, mem2)</code></pre>
<p>Participants remember on average 5.78 words correctly after 5-10
minutes <span class="math inline">\((SD = 2.29)\)</span>.</p>
</div>
<div id="very-delayed-recall" class="section level4">
<h4>Very-delayed recall</h4>
<p>Finally, we score the memory challenge posed at Time 2. Like scoring
the delayed recall task, we have a single column containing responses
fromo all participants, regardless of the original memory condition.</p>
<pre class="r"><code>mem3 = data %&gt;%
  filter(time2 == &quot;yes&quot;) %&gt;% 
  select(proid, mem_condition, very_delayed_recall) %&gt;%
  mutate(newid = 1:nrow(.))

mem3 = mem3 %&gt;%
  mutate(
    very_delayed_recall1 = map(very_delayed_recall, ~sapply(., amatch, correct1, maxDist = distance)),
    very_delayed_recall2 = map(very_delayed_recall, ~sapply(., amatch, correct2, maxDist = distance)),
    very_delayed_recall3 = map(very_delayed_recall, ~sapply(., amatch, correct3, maxDist = distance)),
    very_delayed_recall4 = map(very_delayed_recall, ~sapply(., amatch, correct4, maxDist = distance))
    ) %&gt;%
  gather(variable, very_delayed_memory, very_delayed_recall1:very_delayed_recall4)

mem3 = mem3 %&gt;%
  mutate(
      very_delayed_memory = map(very_delayed_memory, sapply, 
                  FUN = function(x) ifelse(x &gt;0, 1, 0)),
      # count the number of correct answers
      very_delayed_memory = map_dbl(very_delayed_memory, sum, na.rm=T))

mem3 = mem3 %&gt;%
  group_by(proid) %&gt;%
  filter(very_delayed_memory == max(very_delayed_memory)) %&gt;%
  filter(row_number() == 1 ) %&gt;% 
  select(-very_delayed_recall, -variable, -newid) 

data = full_join(data, mem3)</code></pre>
<p>Participants remember on average 1.62 words correctly <span
class="math inline">\((SD = 1.75)\)</span>.</p>
</div>
<div id="correlations" class="section level4">
<h4>Correlations</h4>
<p>Figure @ref(fig:memory-dist) displays the univariate and bivariate
distributions of the memory scores and the bivariate correlations. In
general, there was good spread in the immediate recall and delayed (10
minute) recall variables. Few participants remembered any of the words
after two weeks.</p>
<pre class="r"><code>data %&gt;% 
  select(matches(&quot;memory$&quot;)) %&gt;% 
  corr.test</code></pre>
<pre><code>## Call:corr.test(x = .)
## Correlation matrix 
##                     memory delayed_memory very_delayed_memory
## memory                1.00           0.81                0.38
## delayed_memory        0.81           1.00                0.46
## very_delayed_memory   0.38           0.46                1.00
## Sample Size 
##                     memory delayed_memory very_delayed_memory
## memory                 975            975                 883
## delayed_memory         975            975                 883
## very_delayed_memory    883            883                 883
## Probability values (Entries above the diagonal are adjusted for multiple tests.) 
##                     memory delayed_memory very_delayed_memory
## memory                   0              0                   0
## delayed_memory           0              0                   0
## very_delayed_memory      0              0                   0
## 
##  To see confidence intervals of the correlations, print with the short=FALSE option</code></pre>
<div class="figure">
<img src="1-cleaning_files/figure-html/memory-dist-1.png" alt="Distributions of memory scores across booth time points." width="672" />
<p class="caption">
Distributions of memory scores across booth time points.
</p>
</div>
</div>
</div>
<div id="change-labels-of-device-variable" class="section level3">
<h3>Change labels of device variable</h3>
<p>Longer labels were provided to participants for clarity. However, we
will use shorter labels in our analyses and figures.</p>
<pre class="r"><code>data = data %&gt;% 
  mutate(devicetype = factor(
    devicetype,
    levels = c(&quot;Desktop or laptop computer&quot;, &quot;Mobile&quot;, 
               &quot;Tablet (for example, iPad, Galaxy Tablet, Amazon Fire, etc.)&quot;), 
    labels = c(&quot;Computer&quot;, &quot;Mobile&quot;, &quot;Tablet&quot;)
  ))</code></pre>
</div>
<div id="reorder-demographic-categories" class="section level3">
<h3>Reorder demographic categories</h3>
<p>We set the order of ordinal demographic variables, which helps
generate more interpretable figures and tables.</p>
<pre class="r"><code>data = data %&gt;% 
  mutate(edu = factor(edu, 
                      levels = c(
                        &quot;Less than 12 years&quot;,
                        &quot;High school graduate/GED&quot;,
                        &quot;Currently in college/university&quot;,
                        &quot;Some college/university, but did not graduate&quot;,
                        &quot;Associate degree (2 year)&quot;,
                        &quot;College/university degree (4 year)&quot;,
                        &quot;Currently in graduate or professional school&quot;,
                        &quot;Graduate or professional school degree&quot;))) %&gt;% 
  mutate(hhinc = str_remove(hhinc, &quot; a year&quot;),
         hhinc = str_replace_all(hhinc, &quot;,000&quot;, &quot;K&quot;),
         hhinc = str_replace_all(hhinc, &quot; to &quot;, &quot;-&quot;),
         hhinc = str_replace_all(hhinc, &quot;less than&quot;, &quot;&lt;&quot;),
         hhinc = str_replace_all(hhinc, &quot;more than&quot;, &quot;&gt;&quot;))%&gt;% 
  mutate(hhinc = factor(hhinc,
                        levels = c(
                          &quot;&lt; $20,000&quot;,
                          &quot;$20K-$40K&quot;,
                          &quot;$40K-$60K&quot;,
                          &quot;$60K-$80K&quot;,
                          &quot;$80K-$100K&quot;,
                          &quot;$100K-$120K&quot;,
                          &quot;$120K-$150K&quot;,
                          &quot;$150K-$200K&quot;,
                          &quot;$200K-$250K&quot;,
                          &quot;$250K-$350K&quot;,
                          &quot;$350K-$500K&quot;,
                          &quot;&gt;$500K&quot;
                        )))</code></pre>
</div>
<div id="long-form-dataset" class="section level3">
<h3>Long-form dataset</h3>
<p>We need one dataset that contains the responses to and timing of the
personality items in long form. This will be used for nearly all the
statistical models, which will nest items within person. To create this,
we first select the responses to the items of different formats. For
this set of analyses, we use data collected in both Block 1 and Block 2
– that is, each participant saw the same format for every item during
Block 1, but a random format for each item in Block 2.</p>
<p>These variable names have one of four formats:
<code>[trait]_[abcd]</code> (for example, <code>talkative_a</code>),
<code>[trait]_[abcd]_2</code> (for example, <code>talkative_a_2</code>),
<code>[trait]_[abcd]_3</code> (e.g., <code>talkative_a_3</code>), or
<code>[trait]_[abcd]_3i</code> (e.g., <code>talkative_a_3i</code>). We
search for these items using regular expressions.</p>
<pre class="r"><code>item_responses = str_subset(
  names(data),
  &quot;^([[:alpha:]])+_[abcd](_2)?(_3)?(i)?$&quot;
)</code></pre>
<p>Similarly, we’ll need to know how long it took participants to
respond to these items. These variable names have one of four formats
listed above followed by the string <code>page_submit</code>. We search
for these items using regular expressions.</p>
<pre class="r"><code>item_timing = str_subset(
  names(data), 
  &quot;t_([[:alpha:]])+_[abcd](_2)?(_3)?(i)?_page_submit$&quot;)</code></pre>
<p>We extract just the participant IDs, delayed memory, and these
variables.</p>
<pre class="r"><code>items_df = data %&gt;% 
  select(proid, condition, time2, 
         memory, delayed_memory, very_delayed_memory,
         devicetype, 
         all_of(item_responses), all_of(item_timing))</code></pre>
<p>Next we reshape these data into long form. This requires several
steps. We’ll need to identify whether each value is a response or
timing; we can use the presence of the string <code>t_</code> for this.
Next, we’ll identify the block based on whether the string contains
<code>_2</code> or <code>_3</code>. We also identify whether it ends
with <code>i</code>, indicating the item in block 3 started with “I”.
Then, we identify the condition based on which letter (<code>a</code>,
<code>b</code>, <code>c</code>, or <code>d</code>) follows an
underscore. Throughout, we’ll strip the item string of extraneous
information until we’re left with only the adjective assessed. Finally,
we’ll use spread to create separate columns for the response and the
timing variables.</p>
<pre class="r"><code>items_df = items_df %&gt;%
  gather(item, value, all_of(item_responses), all_of(item_timing)) %&gt;%
  filter(!is.na(value)) %&gt;% 
  # identify whether timing or response
  mutate(variable = ifelse(str_detect(item, &quot;^t_&quot;), &quot;timing&quot;, &quot;response&quot;),
         item = str_remove(item, &quot;^t_&quot;),
         item = str_remove(item, &quot;_page_submit$&quot;)) %&gt;% 
  #identify block
  mutate(
    block = case_when(
      str_detect(item, &quot;_2&quot;) ~ &quot;2&quot;, 
      str_detect(item, &quot;_3&quot;) ~ &quot;3&quot;, 
      TRUE ~ &quot;1&quot;),
    item = str_remove(item, &quot;_[23]&quot;)) %&gt;% 
  # identify presence of &quot;I&quot;
  mutate(i = case_when(
    str_detect(item, &quot;i$&quot;) ~ &quot;Present&quot;,
    TRUE ~ &quot;Absent&quot;),
    item = str_remove(item, &quot;i$&quot;)) %&gt;% 
  separate(item, into = c(&quot;item&quot;, &quot;format&quot;)) %&gt;%
  spread(variable, value)</code></pre>
<div id="remove-human-and-asleep" class="section level4">
<h4>Remove ‘human’ and ‘asleep’</h4>
<p>We also remove responses to the adjectives “human” and “asleep”, as
these are not personality items per-se and included for the purpose of
attention checks.</p>
<pre class="r"><code>items_df = items_df %&gt;% 
  filter(item != &quot;human&quot;) %&gt;% 
  filter(item != &quot;asleep&quot;)</code></pre>
</div>
<div id="label-formatting-conditions" class="section level4">
<h4>Label formatting conditions</h4>
<p>We give labels to the formats, to clarify interpretations and aid
table and figure construction.</p>
<pre class="r"><code>items_df$format = as.factor(items_df$format)
items_df$format = relevel(items_df$format, ref = &quot;a&quot;) 
items_df$format = factor(items_df$format,
                               levels = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;),
                               labels = c(&quot;Adjective\nOnly&quot;, &quot;Am\nAdjective&quot;, &quot;Tend to be\nAdjective&quot;, &quot;Am someone\nwho tends to be\nAdjective&quot;))</code></pre>
</div>
<div id="identify-big-five-mini-markers" class="section level4">
<h4>Identify Big Five mini markers</h4>
<p>Big Five Mini Markers (BF-MM) are used only for the yea-saying
analyses. We identify these adjectives here so that we can appropriately
filter them in or out at each stage of analysis.</p>
<pre class="r"><code>bfmm = c(&quot;quiet&quot;, &quot;unsympathetic&quot;, &quot;relaxed&quot;, &quot;uncreative&quot;, 
         &quot;shy&quot;, &quot;cold&quot;, &quot;unintellectual&quot;)</code></pre>
</div>
<div id="transform-seconds" class="section level4">
<h4>Transform seconds</h4>
<p>The variable <code>seconds</code> appears to have a very severe right
skew (see Figure @ref(fig:1-cleaning-95)). We log-transform this
variable for later analyses.</p>
<pre class="r"><code>items_df = items_df %&gt;% 
  mutate(seconds_log = log(timing))

range(items_df$timing, na.rm=T)</code></pre>
<pre><code>## [1]   0.000 751.823</code></pre>
<pre class="r"><code>range(items_df$seconds_log, na.rm=T)</code></pre>
<pre><code>## [1]     -Inf 6.622501</code></pre>
<div class="figure">
<img src="1-cleaning_files/figure-html/1-cleaning-95-1.png" alt="Distribution of seconds, raw and transformed." width="672" />
<p class="caption">
Distribution of seconds, raw and transformed.
</p>
</div>
</div>
</div>
</div>
<div id="enjoyment" class="section level2">
<h2>Enjoyment</h2>
<p>Finally, in the first wave of data collection, we poll participants
about their enjoyment of the study and experience of taking the survey.
We extract those columns, along with the condition assigned in Block 1,
for later analyses.</p>
<pre class="r"><code>enjoy_df = data_t1 %&gt;% 
  select(proid, condition, devicetype, enjoy_responding, well_designed_study) %&gt;% 
  # convert responses to numeric
  mutate(
    format = tolower(condition),
    format = factor(format,
                    levels = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;),
                    labels = c(&quot;Adjective\nOnly&quot;, 
                               &quot;Am\nAdjective&quot;, 
                               &quot;Tend to be\nAdjective&quot;, 
                               &quot;Am someone\nwho tends to be\nAdjective&quot;)),
    across(
      c(enjoy_responding, well_designed_study),
      ~case_when(
        . == &quot;Very inaccurate&quot;       ~ 1,
        . == &quot;Moderately inaccurate&quot; ~ 2,
        . == &quot;Slightly inaccurate&quot;   ~ 3,
        . == &quot;Slightly accurate&quot;     ~ 4,
        . == &quot;Moderately accurate&quot;   ~ 5,
        . == &quot;Very accurate&quot;         ~ 6,
        TRUE ~ NA_real_
      )
    )
  ) %&gt;% 
  filter(proid %in% items_df$proid)</code></pre>
</div>
<div id="save-files" class="section level2">
<h2>Save files</h2>
<pre class="r"><code># check if folder exists. if not create it
if (!file.exists(here(&quot;objects/&quot;))){
    dir.create(here(&quot;objects/&quot;))
}
save(reverse, file = here(&quot;objects/reverse_vector.Rds&quot;))
save(bfmm, file = here(&quot;objects/bfmm.Rds&quot;))
save(data, file = here(&quot;objects/cleaned_data.Rds&quot;))
save(items_df, file = here(&quot;objects/items_df.Rds&quot;))
save(enjoy_df, file = here(&quot;objects/enjoy_df.Rds&quot;))</code></pre>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
