<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Data cleaning</title>

<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/kePrint-0.0.1/kePrint.js"></script>
<link href="site_libs/lightable-0.0.1/lightable.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/all.css" rel="stylesheet" />
<link href="site_libs/font-awesome-5.1.0/css/v4-shims.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">On item wording effects</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="1-cleaning.html">Data cleaning</a>
</li>
<li>
  <a href="descriptives.html">Descriptives</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Analysis
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="response_style.html">Does item formatting affect response style?</a>
    </li>
    <li>
      <a href="internal.html">Does item formatting affect internal consistency?</a>
    </li>
    <li>
      <a href="test_retest.html">Does item formatting affect test-retest reliability?</a>
    </li>
    <li>
      <a href="timing_format.html">Does timing differ across format?</a>
    </li>
    <li>
      <a href="device.html">Does device type affect response and timing?</a>
    </li>
    <li>
      <a href="subjective.html">Does item formatting affect participant survey enjoyment?</a>
    </li>
  </ul>
</li>
<li>
  <a href="power.html">Power analysis</a>
</li>
<li>
  <a href="workspace.html">R version and packages</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/pie-lab/wording-effects">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Data cleaning</h1>
<h4 class="date">Last updated 2023-05-01</h4>

</div>

<div id="TOC">
<ul>
<li><a href="#workspace" id="toc-workspace"><span class="toc-section-number">0.1</span> Workspace</a></li>
<li><a href="#change-participant-id-values" id="toc-change-participant-id-values"><span class="toc-section-number">0.2</span> Change participant ID values</a></li>
<li><a href="#manually-update-entries" id="toc-manually-update-entries"><span class="toc-section-number">0.3</span> Manually update entries</a></li>
<li><a href="#deidentify-data-only-run-after-data-collection-is-complete" id="toc-deidentify-data-only-run-after-data-collection-is-complete"><span class="toc-section-number">0.4</span> Deidentify data – only run after data collection is complete</a></li>
<li><a href="#time-1" id="toc-time-1"><span class="toc-section-number">0.5</span> Time 1</a>
<ul>
<li><a href="#recode-personality-item-responses-to-numeric" id="toc-recode-personality-item-responses-to-numeric"><span class="toc-section-number">0.5.1</span> Recode personality item responses to numeric</a></li>
<li><a href="#drop-bots-and-inattentive-participants" id="toc-drop-bots-and-inattentive-participants"><span class="toc-section-number">0.5.2</span> Drop bots and inattentive participants</a></li>
</ul></li>
<li><a href="#time-2" id="toc-time-2"><span class="toc-section-number">0.6</span> Time 2</a>
<ul>
<li><a href="#recode-personality-item-responses-to-numeric-1" id="toc-recode-personality-item-responses-to-numeric-1"><span class="toc-section-number">0.6.1</span> Recode personality item responses to numeric</a></li>
<li><a href="#drop-bots-and-inattentive-participants-1" id="toc-drop-bots-and-inattentive-participants-1"><span class="toc-section-number">0.6.2</span> Drop bots and inattentive participants</a></li>
<li><a href="#merge-all-datasets-together" id="toc-merge-all-datasets-together"><span class="toc-section-number">0.6.3</span> Merge all datasets together</a></li>
</ul></li>
<li><a href="#all-data" id="toc-all-data"><span class="toc-section-number">0.7</span> All data</a>
<ul>
<li><a href="#reverse-score-personality-items" id="toc-reverse-score-personality-items"><span class="toc-section-number">0.7.1</span> Reverse score personality items</a></li>
<li><a href="#score-memory-task" id="toc-score-memory-task"><span class="toc-section-number">0.7.2</span> Score memory task</a></li>
<li><a href="#change-labels-of-device-variable" id="toc-change-labels-of-device-variable"><span class="toc-section-number">0.7.3</span> Change labels of device variable</a></li>
<li><a href="#reorder-demographic-categories" id="toc-reorder-demographic-categories"><span class="toc-section-number">0.7.4</span> Reorder demographic categories</a></li>
<li><a href="#long-form-dataset" id="toc-long-form-dataset"><span class="toc-section-number">0.7.5</span> Long-form dataset</a></li>
</ul></li>
<li><a href="#enjoyment" id="toc-enjoyment"><span class="toc-section-number">0.8</span> Enjoyment</a></li>
<li><a href="#save-files" id="toc-save-files"><span class="toc-section-number">0.9</span> Save files</a></li>
</ul>
</div>

<p>The current section documents the data cleaning process.</p>
<div id="workspace" class="section level2" number="0.1">
<h2><span class="header-section-number">0.1</span> Workspace</h2>
<pre class="r"><code>library(here) # for working with files
library(tidyverse) # for cleaning
library(janitor) # for variable names
library(stringi) # for generating random strings
library(glmmTMB) # for multilevel modeling
library(broom) # for presenting results
library(sjPlot) # for figures
library(ggpubr) # for prettier plots
library(kableExtra) # for nicer tables
library(stringdist) # for scoring memory task
library(papaja) # for pretty numbers
library(psych) # for correlation tests
library(broom.mixed) # for tidying multilevel models</code></pre>
</div>
<div id="change-participant-id-values" class="section level2" number="0.2">
<h2><span class="header-section-number">0.2</span> Change participant ID values</h2>
<p>Before we begin, we create new versions of each data_t1 file that can be shared for purposes of reproducibility. These data_t1 files do not include variables that contain potentially identifying meta-data_t1 (e.g., IP address, latitude and longitude). Importantly, we also replace all Prolific ID values with new, random strings, to prevent the possibility that these participants are later identified. We also fix an error that can be introduced through Qualtrics, specifically that all or parts of the text string “Value will be set from panel or URL” is sometimes entered into the text box for ID. Prolific ID values are always 24 characters long and start with a number – we search for strings that meet this criteria.</p>
<p>(We note that the code chunks in this subsection are turned off in the RMarkdown file – <code>eval = F</code> – as readers will not be able to run these chunks.)</p>
<pre class="r"><code># function to load raw file, clean the names, and remove meta-data_t1
# creating a function ensures the same procedure is applied to all
# orginal datasets

load_data = function(path){
  
  full_path = here(path)
  data_obj  = read_rds(path)
  
  data_obj = clean_names(data_obj)
  
  data_obj = data_obj %&gt;%
    select(-end_date,
           -ip_address, 
           -progress, 
           -finished,
           -recorded_date,
           -status,
           -response_id,
           -external_reference, 
           -distribution_channel,
           -user_language,
           -starts_with(&quot;recipient&quot;),
           -starts_with(&quot;location&quot;),
           -starts_with(&quot;meta_info&quot;),
           -prolific_pid)
  
  data_obj = data_obj %&gt;% 
    mutate(proid = str_extract(proid, &quot;\\d([[:alnum:]]{23})&quot;))
  
  return(data_obj)
}

data_t1 &lt;- load_data(&quot;data/data_t1.rds&quot;)
data_2A &lt;- load_data(&quot;data/data_2A.rds&quot;)
data_2B &lt;- load_data(&quot;data/data_2B.rds&quot;)
data_2C &lt;- load_data(&quot;data/data_2C.rds&quot;)
data_2D &lt;- load_data(&quot;data/data_2D.rds&quot;)</code></pre>
</div>
<div id="manually-update-entries" class="section level2" number="0.3">
<h2><span class="header-section-number">0.3</span> Manually update entries</h2>
<p>Several participants notified us of mistaken answers after completing the survey. We fix those entries here.</p>
<pre class="r"><code>data_t1$sex[data_t1$proid == &quot;63b7d7a4ab0b515649d4f4de&quot;] = &quot;Female&quot;
data_t1$devicetype[data_t1$proid == &quot;60da4f9aa1ced7efeecca18a&quot;] = &quot;Tablet (for example, iPad, Galaxy Tablet, Amazon Fire, etc.)&quot;
data_t1$inaccurate_responses[data_t1$proid == &quot;60da4f9aa1ced7efeecca18a&quot;] = &quot;No&quot;</code></pre>
</div>
<div id="deidentify-data-only-run-after-data-collection-is-complete" class="section level2" number="0.4">
<h2><span class="header-section-number">0.4</span> Deidentify data – only run after data collection is complete</h2>
<p>We identify all unique participant IDs. For each, we generate a new string, Then we replace the original ID values with the new strings.</p>
<pre class="r"><code>original_id &lt;- unique(c(data_t1$proid,
                       data_2A$proid,
                       data_2B$proid,
                       data_2C$proid,
                       data_2D$proid))

#remove missing values -- represent bots or tests
original_id = original_id[!is.na(original_id)]

#generate new ids (randoms tring of letters and numbers)
set.seed(202108)
new_id &lt;- stri_rand_strings(n = length(original_id), length = 24)

#replace old string with new string
for(i in 1:length(original_id)){
  data_t1$proid[data_t1$proid == original_id[i]] &lt;- new_id[i]
  data_2A$proid[data_2A$proid == original_id[i]] &lt;- new_id[i]
  data_2B$proid[data_2B$proid == original_id[i]] &lt;- new_id[i]
  data_2C$proid[data_2C$proid == original_id[i]] &lt;- new_id[i]
  data_2D$proid[data_2D$proid == original_id[i]] &lt;- new_id[i]
}</code></pre>
<p>We end by saving each data_t1 frame as new .csv files, to be uploaded to OSF and shared for reproduction.</p>
<pre class="r"><code>write_csv(data_t1, file = here(&quot;deidentified data/data_time1.csv&quot;))
write_csv(data_2A, file = here(&quot;deidentified data/data_time2_A.csv&quot;))
write_csv(data_2B, file = here(&quot;deidentified data/data_time2_B.csv&quot;))
write_csv(data_2C, file = here(&quot;deidentified data/data_time2_C.csv&quot;))
write_csv(data_2D, file = here(&quot;deidentified data/data_time2_D.csv&quot;))</code></pre>
<pre class="r"><code>data_t1 &lt;- read_csv(here(&quot;deidentified data/data_time1.csv&quot;))
data_2A &lt;- read_csv(here(&quot;deidentified data/data_time2_A.csv&quot;))
data_2B &lt;- read_csv(here(&quot;deidentified data/data_time2_B.csv&quot;))
data_2C &lt;- read_csv(here(&quot;deidentified data/data_time2_C.csv&quot;))
data_2D &lt;- read_csv(here(&quot;deidentified data/data_time2_D.csv&quot;))</code></pre>
</div>
<div id="time-1" class="section level2" number="0.5">
<h2><span class="header-section-number">0.5</span> Time 1</h2>
<p>We rename several columns, in order to facilitate the use of regular expressions later. Specifically, we remove the underscores (_) in the columns pertaining to broad-mindedness and self-disciplined.</p>
<pre class="r"><code>names(data_t1) = str_replace(names(data_t1), &quot;broad_mind&quot;, &quot;broadmind&quot;)
names(data_t1) = str_replace(names(data_t1), &quot;self_disciplind&quot;, &quot;selfdisciplined&quot;)</code></pre>
<p>We can also remove the meta-data (timing, etc) around two attention check adjectives, “human” and “asleep”.</p>
<pre class="r"><code>data_t1 = data_t1 %&gt;% 
  select(-starts_with(&quot;t_human&quot;),
         -starts_with(&quot;t_asleep&quot;))</code></pre>
<div id="recode-personality-item-responses-to-numeric" class="section level3" number="0.5.1">
<h3><span class="header-section-number">0.5.1</span> Recode personality item responses to numeric</h3>
<p>We recode the responses to personality items, which we downloaded as text strings. We chose to use text strings as opposed to numbers to avoid any possibility that the Qualtrics-set coding was incorrect. We start this process by identifying the personality items (<code>p_items</code>) using regular expressions. All personality items take a format like <code>outgoing_a</code> or <code>helpful_b_2</code>; that is, they start with the adjective, followed by a letter indicating with which condition or item format the adjective was presented, and sometimes they are followed by a 2, indicating it was the second time the participant saw the adjective. We can represent this pattern using regular expressions.</p>
<pre class="r"><code>p_items = str_extract(names(data_t1), &quot;^[[:alpha:]]*_[abcd](_2)?$&quot;)
p_items = p_items[!is.na(p_items)]

personality_items = select(data_t1, proid, all_of(p_items))</code></pre>
<p>Next, we write a simple function to recode values. We find the <code>case_when</code> function to be the most clear method of communicating the recoding process when moving from string to numeric.</p>
<pre class="r"><code>recode_p = function(x){
  y = case_when(
    x == &quot;Very inaccurate&quot; ~ 1,
    x == &quot;Moderately inaccurate&quot; ~ 2,
    x == &quot;Slightly inaccurate&quot; ~ 3,
    x == &quot;Slightly accurate&quot; ~ 4,
    x == &quot;Moderately accurate&quot; ~ 5,
    x == &quot;Very accurate&quot; ~ 6,
    TRUE ~ NA_real_)
  return(y)
}</code></pre>
<p>Finally, we apply this function to all personality items.</p>
<pre class="r"><code>personality_items = personality_items %&gt;%
  # apply to all variables except proid
  mutate(across(!c(proid), recode_p))</code></pre>
<p>Now we merge the recoded values back into the data_t1.</p>
<pre class="r"><code># remove personality items from data file
data_t1 = select(data_t1, -all_of(p_items))
# merge in recoded personality items
data_t1 = full_join(data_t1, personality_items)</code></pre>
</div>
<div id="drop-bots-and-inattentive-participants" class="section level3" number="0.5.2">
<h3><span class="header-section-number">0.5.2</span> Drop bots and inattentive participants</h3>
<div id="based-on-id" class="section level4" number="0.5.2.1">
<h4><span class="header-section-number">0.5.2.1</span> Based on ID</h4>
<p>Recall that when preparing the data files for sharing, we replaced all Prolific IDs with random strings. A consequence of this cleaning is that any ID entered that did not have a string meeting the Prolific ID format requirements (24 character, starting with a number) was replaced with <code>NA</code>. To remove these bots, we can simply filter out missing ID values.</p>
<p>We removed 0 participants without valid Prolific IDs. (This likely occurred based on sharing of the survey link among Prolific users.)</p>
</div>
<div id="based-on-language" class="section level4" number="0.5.2.2">
<h4><span class="header-section-number">0.5.2.2</span> Based on language</h4>
<pre class="r"><code>data_t1 = data_t1 %&gt;%
  filter(english %in% c(&quot;Well&quot;, &quot;Very well (fluent/native)&quot;))</code></pre>
<p>We removed 1 participants that do not speak english well or very well.</p>
</div>
<div id="based-on-patterns" class="section level4" number="0.5.2.3">
<h4><span class="header-section-number">0.5.2.3</span> Based on patterns</h4>
<p>We remove any participant who provides the same response to over half of the items (17 or more items) from a given block in a row.</p>
<p>To proceed, first we create a dataframe containing just the responses to personality items in the first block.</p>
<pre class="r"><code># first, identify unique adjectives, in order
adjectives = p_items %&gt;%
  str_remove_all(&quot;_.&quot;) %&gt;%
  unique()

# extract block 1 questions using regular expressions
# these follow the personality item format described above, but never end with 2
block1 = data_t1 %&gt;%
  select(proid, matches(&quot;^[[:alpha:]]+_[abcd]$&quot;)) </code></pre>
<p>Next, we rename the variables. Instead of variable names identifying the specific adjective (e.g., outgoing_a), we need variable names which indicate the order in which the adjective was seen by the participant (e.g., trait01_a). This will help us determine patterns by item order, rather than adjective content. Participants all saw adjectives in the same order (i.e., all participants, regardless of condition, saw outgoing first).</p>
<pre class="r"><code>#rename variables 
n = 0
for(i in adjectives){ # for each adjective
  n = n+1 # identify its location in the presentation
  names(block1) = str_replace(names(block1), #in variable names
                              # replace the adjective string
                              i, 
                              # with the word trait followed by its place
                              paste0(&quot;trait&quot;, str_pad(n, 2, pad = &quot;0&quot;)))
}</code></pre>
<p>We use <code>gather</code> and <code>spread</code> to quickly combine columns measuring the same trait. That is, instead of having columns trait01_a, trait01_b, trait01_c, and trait01_d, we now have a single column called trait01.</p>
<pre class="r"><code>block1 = block1 %&gt;%
  gather(item, response, -proid) %&gt;%
  filter(!is.na(response)) %&gt;%
  separate(item, into = c(&quot;item&quot;, &quot;format&quot;)) %&gt;%
  select(-format) %&gt;%
  spread(item, response)</code></pre>
<p>To count the number of runs, we loop through participants and, within participant, loop through columns. Within participant, we create an object called <code>run</code>. If a response to a personality item is the same as the participant’s response to the previous item, we increase the value of <code>run</code> by 1. If this new value is the largest <code>run</code> value for that participant, it becomes the value of an object called <code>maxrun</code>. If the participant gives a new response, <code>run</code> is reset to 0. We record the <code>maxrun</code> value for each partipant in a variable called <code>block1_runs</code>.</p>
<pre class="r"><code>block1_runs = numeric(length = nrow(block1))


for(i in 1:nrow(block1)){
  run = 0
  maxrun = 0
  for(j in 3:ncol(block1)){
    if(block1[i,j] == block1[i, j-1]){
      run = run+1
      if(run &gt; maxrun) maxrun = run
      } else{ run = 0}
  } 
  block1_runs[i] = maxrun
}

#add to data_t1 frame
block1$block1_runs = block1_runs</code></pre>
<p>Here we repeat the process described above with Block 2 data.</p>
<pre class="r"><code># extract block 2 questions
block2 = data_t1 %&gt;%
  select(proid, matches(&quot;^[[:alpha:]]+_[abcd]_2$&quot;)) 

#rename variables 
n = 0
for(i in adjectives){
  n = n+1
  names(block2) = str_replace(names(block2), i, paste0(&quot;trait&quot;, str_pad(n, 2, pad = &quot;0&quot;)))
}

block2 = block2 %&gt;%
  gather(item, response, -proid) %&gt;%
  filter(!is.na(response)) %&gt;%
  mutate(item = str_remove(item, &quot;_2&quot;)) %&gt;%
  separate(item, into = c(&quot;item&quot;, &quot;format&quot;)) %&gt;%
  select(-format) %&gt;%
  spread(item, response)

block2_runs = numeric(length = nrow(block2))

#identify max run for each participant
for(i in 1:nrow(block2)){
  run = 0
  maxrun = 0
  for(j in 3:ncol(block2)){
    if(block2[i,j] == block2[i, j-1]){
      run = run+1
      if(run &gt; maxrun) maxrun = run
      } else{ run = 0}
  } 
  block2_runs[i] = maxrun
}

#add to data_t1 frame
block2$block2_runs = block2_runs</code></pre>
<p>We combine the variables holding the maximum runs into a single data frame. We will remove participants if their maximum run in either block was greater than or equal to 17. See Figure <a href="#fig:1-cleaning-24">1</a> for a visualization of the spread and associations between run lengths across participants.</p>
<pre class="r"><code>#combine results
runs_data = block1 %&gt;%
  select(proid, block1_runs) %&gt;%
  full_join(select(block2, proid, block2_runs)) %&gt;%
  mutate(
    remove = case_when(
      block1_runs &gt;= 17 ~ &quot;Remove&quot;,
      block2_runs &gt;= 17 ~ &quot;Remove&quot;,
      TRUE ~ &quot;Keep&quot;
    ))</code></pre>
<div class="figure"><span style="display:block;" id="fig:1-cleaning-24"></span>
<img src="1-cleaning_files/figure-html/1-cleaning-24-1.png" alt="Maximum number of same consecutive responses in personality blocks." width="672" />
<p class="caption">
Figure 1: Maximum number of same consecutive responses in personality blocks.
</p>
</div>
<p>There were 6 participants who provided the same answer 17 or more times in a row. These participants were removed from the analyses.</p>
<pre class="r"><code>data_t1 = data_t1 %&gt;%
  full_join(select(runs_data, proid, remove)) %&gt;%
  filter(remove != &quot;Remove&quot;) %&gt;%
  select(-remove)

rm(runs_data)</code></pre>
</div>
<div id="based-on-inattentive-responding" class="section level4" number="0.5.2.4">
<h4><span class="header-section-number">0.5.2.4</span> Based on inattentive responding</h4>
<p>We expect to exclude any participant who has an average response of 4 (“slightly agree”) or greater to the attention check items. Two items from the Inattentive and Deviant Responding Inventory for Adjectives (IDRIA) scale (Kay &amp; Saucier, in prep) have been included here, in part to help evaluate the extent of inattentive responding but also to consider the effect of item wording on these items. The two items used here (i.e., “Asleep”, “Human”) were chosen to be as inconspicuous as possible, so as to not to inflate item response duration. The frequency item (i.e., “human”) will be reverse-scored, so that higher scores on both the infrequency and frequency items reflect greater inattentive responding. Figure <a href="#fig:1-cleaning-27">2</a> shows the distribution of average responses to attention check items.</p>
<pre class="r"><code>in_average = data_t1 %&gt;%
  # reverse score human
  mutate(across(matches(&quot;^human&quot;),  ~(.x*-1)+7)) %&gt;%
  # select id and attention check items
  select(proid, matches(&quot;^human&quot;), matches(&quot;^asleep&quot;)) %&gt;% 
  gather(item, response, -proid) %&gt;%
  filter(!is.na(response)) %&gt;%
  group_by(proid) %&gt;%
  summarise(avg = mean(response)) %&gt;%
  mutate(
    remove = case_when(
      avg &gt;= 4 ~ &quot;Remove&quot;,
      TRUE ~ &quot;Keep&quot;))</code></pre>
<div class="figure"><span style="display:block;" id="fig:1-cleaning-27"></span>
<img src="1-cleaning_files/figure-html/1-cleaning-27-1.png" alt="Average response to inattention check items" width="672" />
<p class="caption">
Figure 2: Average response to inattention check items
</p>
</div>
<p>We remove 1 participants whose responses suggest inattention.</p>
<pre class="r"><code>data_t1 = data_t1 %&gt;%
  full_join(select(in_average, proid, remove)) %&gt;%
  filter(remove != &quot;Remove&quot;) %&gt;%
  select(-remove)</code></pre>
</div>
<div id="based-on-average-time-to-respond-to-personality-items" class="section level4" number="0.5.2.5">
<h4><span class="header-section-number">0.5.2.5</span> Based on average time to respond to personality items</h4>
<p>First, select just the timing of the personality items. We do this by searching for specific strings: “t_[someword]<em>[a or b or c or d]</em>(maybe 2_)_page_submit.”</p>
<pre class="r"><code>timing_data = data_t1 %&gt;%
  select(proid, matches(&quot;t_[[:alpha:]]*_[abcd](_2)?_page_submit&quot;))</code></pre>
<p>Next we gather into long form and remove missing timing values</p>
<pre class="r"><code>timing_data = timing_data %&gt;%
  gather(variable, timing, -proid) %&gt;%
  filter(!is.na(timing))</code></pre>
<p>To check, each participant should have the same number of responses: 76.</p>
<pre class="r"><code>timing_data %&gt;%
  group_by(proid) %&gt;%
  count() %&gt;%
  ungroup() %&gt;% 
  summarise(min(n), max(n))</code></pre>
<pre><code>## # A tibble: 1 × 2
##   `min(n)` `max(n)`
##      &lt;int&gt;    &lt;int&gt;
## 1       76       76</code></pre>
<p>Excellent! Now we calculate the average response time per item for each participant. We mark a participant for removal if their average time is less than 1 second or greater than 30. See Figure <a href="#fig:1-cleaning-33">3</a> for a distribution of average response time.</p>
<pre class="r"><code>timing_data = timing_data %&gt;%
  group_by(proid) %&gt;%
  summarise(m_time = mean(timing)) %&gt;%
  mutate(remove = case_when(
    m_time &lt; 1 ~ &quot;Remove&quot;,
    m_time &gt; 30 ~ &quot;Remove&quot;,
    TRUE ~ &quot;Keep&quot;
  ))</code></pre>
<div class="figure"><span style="display:block;" id="fig:1-cleaning-33"></span>
<img src="1-cleaning_files/figure-html/1-cleaning-33-1.png" alt="Distribution of average time to respond to personality items." width="672" />
<p class="caption">
Figure 3: Distribution of average time to respond to personality items.
</p>
</div>
<pre class="r"><code>data_t1 = inner_join(data_t1, filter(timing_data, remove == &quot;Keep&quot;)) %&gt;%
  select(-remove)</code></pre>
<p>Based on timing, we removed 9 participants.</p>
<p>We create a variable which indicates the Block 1 condition of each participant. This is used in two places: first, in recruiting participants at Time 2 (participants are given the same format at Time 2 as they received in Block 1), and second, in selecting the corret items during the test-retest analyses.</p>
<pre class="r"><code>data_t1 = data_t1 %&gt;% 
  mutate(condition = case_when(
    !is.na(outgoing_a) ~ &quot;A&quot;,
    !is.na(outgoing_b) ~ &quot;B&quot;,
    !is.na(outgoing_c) ~ &quot;C&quot;,
    !is.na(outgoing_d) ~ &quot;D&quot;,
  ))</code></pre>
<p>At this point, we’ll extract the Prolific ID numbers. These participants will be eligible to take the survey at Time 2.</p>
<pre class="r"><code>data_t1 %&gt;% 
  select(proid, condition) %&gt;% 
  write_csv(file = here(&quot;data/elligible_proid.csv&quot;))</code></pre>
</div>
</div>
</div>
<div id="time-2" class="section level2" number="0.6">
<h2><span class="header-section-number">0.6</span> Time 2</h2>
<pre class="r"><code>data_2 = data_2A %&gt;% 
  full_join(data_2B) %&gt;% 
  full_join(data_2C) %&gt;% 
  full_join(data_2D)</code></pre>
<p>Rename the following columns.</p>
<pre class="r"><code>data_2 = data_2 %&gt;%
  rename(start_date2 = start_date,
         duration_in_seconds2 = duration_in_seconds)</code></pre>
<p>We rename several columns, in order to facilitate the use of regular expressions later. Specifically, we remove the underscores (_) in the columns pertaining to broad-mindedness and self-disciplined.</p>
<pre class="r"><code>names(data_2) = str_replace(names(data_2), &quot;broad_mind&quot;, &quot;broadmind&quot;)
names(data_2) = str_replace(names(data_2), &quot;self_disciplind&quot;, &quot;selfdisciplined&quot;)</code></pre>
<p>We can also remove the meta-data (timing, etc) around two attention check adjectives, “human” and “asleep”.</p>
<pre class="r"><code>data_2 = data_2 %&gt;% 
  select(-starts_with(&quot;t_human&quot;),
         -starts_with(&quot;t_asleep&quot;))</code></pre>
<div id="recode-personality-item-responses-to-numeric-1" class="section level3" number="0.6.1">
<h3><span class="header-section-number">0.6.1</span> Recode personality item responses to numeric</h3>
<p>We recode the responses to personality items, which we downloaded as text strings. Here, all items end with <code>_3</code> and sometimes with <code>i</code>.</p>
<pre class="r"><code>p_items_2 = str_extract(names(data_2), &quot;^[[:alpha:]]*_[abcd]_3(i)?$&quot;)
p_items_2 = p_items_2[!is.na(p_items_2)]

personality_items_2 = select(data_2, proid, all_of(p_items_2))</code></pre>
<p>We apply the recoding function to all personality items.</p>
<pre class="r"><code>personality_items_2 = personality_items_2 %&gt;%
  mutate(
    across(!c(proid), recode_p))</code></pre>
<p>Now we merge this back into the data_2.</p>
<pre class="r"><code>data_2 = select(data_2, -all_of(p_items_2))
data_2 = full_join(data_2, personality_items_2)</code></pre>
</div>
<div id="drop-bots-and-inattentive-participants-1" class="section level3" number="0.6.2">
<h3><span class="header-section-number">0.6.2</span> Drop bots and inattentive participants</h3>
<p>This code recreates the steps outlined in detail above for Time 1. Please refer to the descriptions above for justification and explaination of the code presented here.</p>
<div id="based-on-id-1" class="section level4" number="0.6.2.1">
<h4><span class="header-section-number">0.6.2.1</span> Based on ID</h4>
<p>We also check that the ID in time 2 matches an ID in time 1.</p>
<pre class="r"><code>data_2 = data_2 %&gt;% 
  filter(proid %in% data_t1$proid)</code></pre>
<p>We removed 2 participants without valid Prolific IDs.</p>
</div>
<div id="based-on-patterns-1" class="section level4" number="0.6.2.2">
<h4><span class="header-section-number">0.6.2.2</span> Based on patterns</h4>
<p>We remove any participant who provides the same response to over half of the items (17 or more items) from a given block in a row. The distribution of runs in Time 2 is depicted in Figure <a href="#fig:1-cleaning-55">4</a>.</p>
<pre class="r"><code># first, identify unique adjectives, in order
adjectives = p_items_2 %&gt;%
  str_remove_all(&quot;_.&quot;) %&gt;%
  unique()

# extract block 3 questions
block3 = data_2 %&gt;%
  select(proid, all_of(p_items_2)) 

#rename variables 
n = 0
for(i in adjectives){
  n = n+1
  names(block3) = str_replace(names(block3), i, paste0(&quot;trait&quot;, str_pad(n, 2, pad = &quot;0&quot;)))
}


block3 = block3 %&gt;%
  gather(item, response, -proid) %&gt;%
  filter(!is.na(response)) %&gt;%
  mutate(item = str_remove(item, &quot;_3(i)?$&quot;)) %&gt;% 
  separate(item, into = c(&quot;item&quot;, &quot;format&quot;)) %&gt;% 
  select(-format) %&gt;%
  spread(item, response)

block3_runs = numeric(length = nrow(block3))

for(i in 1:nrow(block3)){
  run = 0
  maxrun = 0
  for(j in 3:ncol(block3)){
    if(block3[i,j] == block3[i, j-1]){
      run = run+1
      if(run &gt; maxrun) maxrun = run
      } else{ run = 0}
  } 
  block3_runs[i] = maxrun
}

#add to data_2 frame
block3$block3_runs = block3_runs</code></pre>
<pre class="r"><code>#combine results
runs_data_2 = block3 %&gt;%
  select(proid, block3_runs) %&gt;%
  mutate(
    remove = case_when(
      block3_runs &gt;= 17 ~ &quot;Remove&quot;,
      TRUE ~ &quot;Keep&quot;
    ))</code></pre>
<div class="figure"><span style="display:block;" id="fig:1-cleaning-55"></span>
<img src="1-cleaning_files/figure-html/1-cleaning-55-1.png" alt="Maximum number of same consecutive responses in personality block 3." width="672" />
<p class="caption">
Figure 4: Maximum number of same consecutive responses in personality block 3.
</p>
</div>
<p>There were 0 participants who provided the same answer 17 or more times in a row. These participants were removed from the analyses.</p>
<pre class="r"><code>data_2 = data_2 %&gt;%
  full_join(select(runs_data_2, proid, remove)) %&gt;%
  filter(remove != &quot;Remove&quot;) %&gt;%
  select(-remove)

rm(runs_data_2)</code></pre>
</div>
<div id="based-on-inattentive-responding-1" class="section level4" number="0.6.2.3">
<h4><span class="header-section-number">0.6.2.3</span> Based on inattentive responding</h4>
<p>Participants who respond positively to the adjective <em>asleep</em> or negatively to the word <em>human</em> are assumed to be inattentive. We filter out participants whose average response to these two items is greater than or equal to 4 (see Figure <a href="#fig:1-cleaning-59">5</a> for the distribution).</p>
<pre class="r"><code>in_average = data_2 %&gt;%
  # reverse score human
  mutate(across(matches(&quot;^human&quot;),  ~(.x*-1)+7)) %&gt;%
  # select id and attention check items
  select(proid, matches(&quot;^human&quot;), matches(&quot;^asleep&quot;)) %&gt;% 
  gather(item, response, -proid) %&gt;%
  filter(!is.na(response)) %&gt;%
  group_by(proid) %&gt;%
  summarise(avg = mean(response)) %&gt;%
  mutate(
    remove = case_when(
      avg &gt;= 4 ~ &quot;Remove&quot;,
      TRUE ~ &quot;Keep&quot;))</code></pre>
<div class="figure"><span style="display:block;" id="fig:1-cleaning-59"></span>
<img src="1-cleaning_files/figure-html/1-cleaning-59-1.png" alt="Average response to inattention check items" width="672" />
<p class="caption">
Figure 5: Average response to inattention check items
</p>
</div>
<p>We remove 1 participants whose responses suggest inattention.</p>
<pre class="r"><code>data_2 = data_2 %&gt;%
  full_join(select(in_average, proid, remove)) %&gt;%
  filter(remove != &quot;Remove&quot;) %&gt;%
  select(-remove)</code></pre>
</div>
<div id="based-on-average-time-to-respond-to-personality-items-1" class="section level4" number="0.6.2.4">
<h4><span class="header-section-number">0.6.2.4</span> Based on average time to respond to personality items</h4>
<p>Participants who take too little (&lt; 1 second) or too long (greater than 30 seconds) on average to answer each personality item are excluded. See Figure <a href="#fig:1-cleaning-64">6</a> for the distribution of average response time per item.</p>
<pre class="r"><code>timing_data_2 = data_2 %&gt;%
  select(proid, matches(&quot;t_[[:alpha:]]*_[abcd]_3(i)?_page_submit&quot;))

timing_data_2 = timing_data_2 %&gt;%
  gather(variable, timing, -proid) %&gt;%
  filter(!is.na(timing))</code></pre>
<p>To check, each participant should have the same number of responses: 33.</p>
<pre class="r"><code>timing_data_2 %&gt;%
  group_by(proid) %&gt;%
  count() %&gt;%
  ungroup() %&gt;% 
  summarise(min(n), max(n))</code></pre>
<pre><code>## # A tibble: 1 × 2
##   `min(n)` `max(n)`
##      &lt;int&gt;    &lt;int&gt;
## 1       37       38</code></pre>
<pre class="r"><code>timing_data_2 = timing_data_2 %&gt;%
  group_by(proid) %&gt;%
  summarise(m_time = mean(timing)) %&gt;%
  mutate(remove = case_when(
    m_time &lt; 1 ~ &quot;Remove&quot;,
    m_time &gt; 30 ~ &quot;Remove&quot;,
    TRUE ~ &quot;Keep&quot;
  ))</code></pre>
<div class="figure"><span style="display:block;" id="fig:1-cleaning-64"></span>
<img src="1-cleaning_files/figure-html/1-cleaning-64-1.png" alt="Distribution of average time to respond to personality items in Block 3." width="672" />
<p class="caption">
Figure 6: Distribution of average time to respond to personality items in Block 3.
</p>
</div>
<pre class="r"><code>data_2 = inner_join(data_2, filter(timing_data_2, remove == &quot;Keep&quot;)) %&gt;%
  select(-remove)</code></pre>
</div>
</div>
<div id="merge-all-datasets-together" class="section level3" number="0.6.3">
<h3><span class="header-section-number">0.6.3</span> Merge all datasets together</h3>
<p>We merge the Time 1 and Time 2 datasets together here.</p>
<pre class="r"><code>data_2 = data_2 %&gt;% 
  select(proid, start_date2, duration_in_seconds2, very_delayed_recall, contains(&quot;_3&quot;)) %&gt;% 
  mutate(time2 = &quot;yes&quot;) #indicates participant in time 2

data = data_t1 %&gt;% full_join(data_2)</code></pre>
</div>
</div>
<div id="all-data" class="section level2" number="0.7">
<h2><span class="header-section-number">0.7</span> All data</h2>
<div id="reverse-score-personality-items" class="section level3" number="0.7.1">
<h3><span class="header-section-number">0.7.1</span> Reverse score personality items</h3>
<p>The following items are (typically) negatively correlated with the others: reckless, moody, worrying, nervous, careless, impulsive. We reverse-score them to ease interpretation of associations and means in the later sections. In short, all traits will be scored such that larger numbers are indicative of the more socially desirable end of the spectrum.</p>
<pre class="r"><code>data = data %&gt;%
  mutate(
    across(matches(&quot;^reckless&quot;),       ~(.x*-1)+7),
    across(matches(&quot;^moody&quot;),          ~(.x*-1)+7),
    across(matches(&quot;^worrying&quot;),       ~(.x*-1)+7),
    across(matches(&quot;^nervous&quot;),        ~(.x*-1)+7),
    across(matches(&quot;^careless&quot;),       ~(.x*-1)+7),
    across(matches(&quot;^impulsive&quot;),      ~(.x*-1)+7),
    across(matches(&quot;^quiet&quot;),          ~(.x*-1)+7),
    across(matches(&quot;^unsympathetic&quot;),  ~(.x*-1)+7),
    across(matches(&quot;^uncreative&quot;),     ~(.x*-1)+7),
    across(matches(&quot;^shy&quot;),            ~(.x*-1)+7),
    across(matches(&quot;^cold&quot;),           ~(.x*-1)+7),
    across(matches(&quot;^unintellectual&quot;), ~(.x*-1)+7))</code></pre>
<p>We also create a vector noting the items that are reverse scored. We use this later in tables, to help identify patterns when looking at analyses within-adjective. We use this object elsewhere in the analyses.</p>
<pre class="r"><code>reverse = c(&quot;reckless&quot;, &quot;moody&quot;, &quot;worrying&quot;, &quot;nervous&quot;, &quot;careless&quot;, &quot;impulsive&quot;)</code></pre>
</div>
<div id="score-memory-task" class="section level3" number="0.7.2">
<h3><span class="header-section-number">0.7.2</span> Score memory task</h3>
<p>Now we score the memory task. We start by creating vectors of the correct responses.</p>
<pre class="r"><code>correct1 = c(&quot;book&quot;, &quot;child&quot;, &quot;gold&quot;, &quot;hotel&quot;, &quot;king&quot;, 
             &quot;market&quot;, &quot;paper&quot;, &quot;river&quot;, &quot;skin&quot;, &quot;tree&quot;)

correct2 = c(&quot;butter&quot;, &quot;college&quot;, &quot;dollar&quot;, &quot;earth&quot;, &quot;flag&quot;, 
             &quot;home&quot;, &quot;machine&quot;, &quot;ocean&quot;, &quot;sky&quot;, &quot;wife&quot;)

correct3 = c(&quot;blood&quot;, &quot;corner&quot;, &quot;engine&quot;, &quot;girl&quot;, &quot;house&quot;, 
             &quot;letter&quot;, &quot;rock&quot;, &quot;shoes&quot;, &quot;valley&quot;, &quot;woman&quot;)

correct4 = c(&quot;baby&quot;, &quot;church&quot;, &quot;doctor&quot;, &quot;fire&quot;, &quot;garden&quot;, 
             &quot;palace&quot;, &quot;sea&quot;, &quot;table&quot;, &quot;village&quot;, &quot;water&quot;)</code></pre>
<p>Next we convert all responses to lowercase. Then we break the string of responses into a vector containing many strings.</p>
<pre class="r"><code>data = data %&gt;%
  mutate(
    across(matches(&quot;recall&quot;),tolower), # convert to lower
    #replace carriage return with space
    across(matches(&quot;recall&quot;), 
           \(x) str_replace_all(x, pattern = &quot;\\n&quot;, replacement = &quot;,&quot;)),
    # remove spaces
    across(matches(&quot;recall&quot;), 
           \(x) str_replace_all(x, pattern = &quot; &quot;, replacement = &quot;,&quot;)),
    # remove doubles
    across(matches(&quot;recall&quot;), 
           \(x) str_replace_all(x, pattern = &quot;,,&quot;, replacement = &quot;,&quot;)),
    #remove last comma
    across(matches(&quot;recall&quot;), 
           \(x) str_remove(x, pattern = &quot;,$&quot;)),
    # split the strings based on the spaces
    across(matches(&quot;recall&quot;), 
           \(x) str_split(x, pattern = &quot;,&quot;)))</code></pre>
<div id="immediate-recall" class="section level4" number="0.7.2.1">
<h4><span class="header-section-number">0.7.2.1</span> Immediate recall</h4>
<p>Now we use the <code>amatch</code> function in the <code>stringdist</code> package to look for exact (or close) matches to the target words. This function returns for each word either the position of the key in which you can find the target word or <code>NA</code> to indicate the word or a close match does not exist in the string.</p>
<pre class="r"><code>distance = 1 #maximum distance between target word and correct response
data = data %&gt;%
  mutate(
    memory1 = map(recall1, ~sapply(., amatch, correct1, maxDist = distance)),
    memory2 = map(recall2, ~sapply(., amatch, correct2, maxDist = distance)),
    memory3 = map(recall3, ~sapply(., amatch, correct3, maxDist = distance)),
    memory4 = map(recall4, ~sapply(., amatch, correct4, maxDist = distance))
    )</code></pre>
<p>We count the number of correct answers. This gets complicated; in lieu of writing out a paragraph explanation, we have opted for in-text comments to orient those interested in following the code.</p>
<pre class="r"><code>data = data %&gt;%
  mutate(
    across(starts_with(&quot;memory&quot;),
      #replace position with 1
      ~map(., sapply, FUN = function(x) ifelse(x &gt;0, 1, 0))),
    across(starts_with(&quot;recall&quot;),
           # are there non-missing values in the original response?
           ~map_dbl(., 
                    .f = function(x) sum(!is.na(x))), 
           .names = &quot;{.col}_miss&quot;),
    across(starts_with(&quot;memory&quot;),
      #replace position with 1
      # count the number of correct answers
      ~map_dbl(., sum, na.rm=T))) %&gt;%
  mutate(
    memory1 = case_when(
      # if there were no responses, make the answer NA
      recall1_miss == 0 ~ NA_real_,
      # otherwise, the number of correct guesses
      TRUE ~ memory1),
    memory2 = case_when(
      recall2_miss == 0 ~ NA_real_,
      TRUE ~ memory2),
    memory3 = case_when(
      recall3_miss == 0 ~ NA_real_,
      TRUE ~ memory3),
    memory4 = case_when(
      recall4_miss == 0 ~ NA_real_,
      TRUE ~ memory4)) %&gt;%
  # no longer need the missing count variables
  select(-ends_with(&quot;miss&quot;))</code></pre>
<p>Finally, we want to go from 4 columns (one for each recall test), to two: one that has the number of correct responses, and one that indicates which version they saw.</p>
<pre class="r"><code>data = data %&gt;%
  select(proid, starts_with(&quot;memory&quot;)) %&gt;%
  gather(mem_condition, memory, -proid) %&gt;%
  filter(!is.na(memory)) %&gt;%
  mutate(mem_condition = str_remove(mem_condition, &quot;memory&quot;)) %&gt;%
  full_join(data)</code></pre>
<p>To demonstrate the accuracy of the code, here we present a random subset of participants’ raw responses and their assigned memory score.</p>
<pre class="r"><code>#from memory condition 1
data %&gt;% 
  filter(mem_condition == 1) %&gt;% 
  select(recall1, memory) %&gt;% 
  sample_n(3) %&gt;% 
  mutate(recall1 = map_chr(recall1, paste, collapse = &quot;, &quot;))</code></pre>
<pre><code>## # A tibble: 3 × 2
##   recall1                                          memory
##   &lt;chr&gt;                                             &lt;dbl&gt;
## 1 child, gold, hotel, bed, river, tree, king, skin      7
## 2 book, gold, child, paper, king                        5
## 3 book, , child, cold, river                            4</code></pre>
<pre class="r"><code>#from memory condition 2
data %&gt;% 
  filter(mem_condition == 2) %&gt;% 
  select(recall2, memory) %&gt;% 
  sample_n(3) %&gt;% 
  mutate(recall2 = map_chr(recall2, paste, collapse = &quot;, &quot;))</code></pre>
<pre><code>## # A tibble: 3 × 2
##   recall2                                                         memory
##   &lt;chr&gt;                                                            &lt;dbl&gt;
## 1 butter, college, flag, machine, wife                                 5
## 2 butter, college, dollar, earth, house, wife, home, sky, ocean        8
## 3 butter, college, earth, home, sky, wife, dollar, machine, ocean      9</code></pre>
<pre class="r"><code>#from memory condition 3
data %&gt;% 
  filter(mem_condition == 3) %&gt;% 
  select(recall3, memory) %&gt;% 
  sample_n(3) %&gt;% 
  mutate(recall3 = map_chr(recall3, paste, collapse = &quot;, &quot;))</code></pre>
<pre><code>## # A tibble: 3 × 2
##   recall3                                                 memory
##   &lt;chr&gt;                                                    &lt;dbl&gt;
## 1 blood, house, woman, letter, shoes, rock                     6
## 2 blood, corner, engine, girl, house, valley, rock, woman      8
## 3 woman, valley, girl, shoes, rock, engine, blood, corner      8</code></pre>
<pre class="r"><code>#from memory condition 4
data %&gt;% 
  filter(mem_condition == 4) %&gt;% 
  select(recall4, memory) %&gt;% 
  sample_n(3) %&gt;% 
  mutate(recall4 = map_chr(recall4, paste, collapse = &quot;, &quot;))</code></pre>
<pre><code>## # A tibble: 3 × 2
##   recall4                                                 memory
##   &lt;chr&gt;                                                    &lt;dbl&gt;
## 1 baby, church, fire, water, sea, palace, garden               7
## 2 baby, church, fire, village, doctor, garden, water, sea      8
## 3 baby, garden, sea, table, village                            5</code></pre>
<p>Participants remember on average 6.76 words correctly <span class="math inline">\((SD = 1.96)\)</span>.</p>
<table class="table" style="margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:1-cleaning-77">Table 1: </span>Memory responses by condition
</caption>
<thead>
<tr>
<th style="text-align:left;">
Condition
</th>
<th style="text-align:right;">
Mean
</th>
<th style="text-align:right;">
SD
</th>
<th style="text-align:right;">
Min
</th>
<th style="text-align:right;">
Max
</th>
<th style="text-align:right;">
N
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
1
</td>
<td style="text-align:right;">
6.84
</td>
<td style="text-align:right;">
2.05
</td>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
245
</td>
</tr>
<tr>
<td style="text-align:left;">
2
</td>
<td style="text-align:right;">
6.42
</td>
<td style="text-align:right;">
1.87
</td>
<td style="text-align:right;">
1
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
241
</td>
</tr>
<tr>
<td style="text-align:left;">
3
</td>
<td style="text-align:right;">
6.78
</td>
<td style="text-align:right;">
2.03
</td>
<td style="text-align:right;">
0
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
245
</td>
</tr>
<tr>
<td style="text-align:left;">
4
</td>
<td style="text-align:right;">
7.02
</td>
<td style="text-align:right;">
1.83
</td>
<td style="text-align:right;">
2
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
243
</td>
</tr>
</tbody>
</table>
</div>
<div id="delayed-recall" class="section level4" number="0.7.2.2">
<h4><span class="header-section-number">0.7.2.2</span> Delayed recall</h4>
<p>A challenge with the delayed recall task is identifying the memory condition that participants were assigned to, but this is made easier by the work done above. The following code mainly reproduces the steps used for scoring the immediate memory recall task. The main difference is that we have a single column containing all responses (<code>delayed_recall</code>), regardless of which memory condition participants were assigned to. We score this response against all four answer keys, then select the maximum (best) score.</p>
<pre class="r"><code>mem2 = data %&gt;%
  select(proid, mem_condition, delayed_recall) %&gt;%
  mutate(newid = 1:nrow(.))

mem2 = mem2 %&gt;%
  mutate(
    delayed_recall1 = map(delayed_recall, ~sapply(., amatch, correct1, maxDist = distance)),
    delayed_recall2 = map(delayed_recall, ~sapply(., amatch, correct2, maxDist = distance)),
    delayed_recall3 = map(delayed_recall, ~sapply(., amatch, correct3, maxDist = distance)),
    delayed_recall4 = map(delayed_recall, ~sapply(., amatch, correct4, maxDist = distance))
    ) %&gt;%
  gather(variable, delayed_memory, delayed_recall1:delayed_recall4)

mem2 = mem2 %&gt;%
  mutate(
      delayed_memory = map(delayed_memory, sapply, 
                  FUN = function(x) ifelse(x &gt;0, 1, 0)),
      # count the number of correct answers
      delayed_memory = map_dbl(delayed_memory, sum, na.rm=T))

mem2 = mem2 %&gt;%
  group_by(proid) %&gt;%
  filter(delayed_memory == max(delayed_memory)) %&gt;%
  filter(row_number() == 1 ) %&gt;% 
  select(-delayed_recall, -variable, -newid)

data = inner_join(data, mem2)</code></pre>
<p>Participants remember on average 5.78 words correctly after 5-10 minutes <span class="math inline">\((SD = 2.29)\)</span>.</p>
</div>
<div id="very-delayed-recall" class="section level4" number="0.7.2.3">
<h4><span class="header-section-number">0.7.2.3</span> Very-delayed recall</h4>
<p>Finally, we score the memory challenge posed at Time 2. Like scoring the delayed recall task, we have a single column containing responses fromo all participants, regardless of the original memory condition.</p>
<pre class="r"><code>mem3 = data %&gt;%
  filter(time2 == &quot;yes&quot;) %&gt;% 
  select(proid, mem_condition, very_delayed_recall) %&gt;%
  mutate(newid = 1:nrow(.))

mem3 = mem3 %&gt;%
  mutate(
    very_delayed_recall1 = map(very_delayed_recall, ~sapply(., amatch, correct1, maxDist = distance)),
    very_delayed_recall2 = map(very_delayed_recall, ~sapply(., amatch, correct2, maxDist = distance)),
    very_delayed_recall3 = map(very_delayed_recall, ~sapply(., amatch, correct3, maxDist = distance)),
    very_delayed_recall4 = map(very_delayed_recall, ~sapply(., amatch, correct4, maxDist = distance))
    ) %&gt;%
  gather(variable, very_delayed_memory, very_delayed_recall1:very_delayed_recall4)

mem3 = mem3 %&gt;%
  mutate(
      very_delayed_memory = map(very_delayed_memory, sapply, 
                  FUN = function(x) ifelse(x &gt;0, 1, 0)),
      # count the number of correct answers
      very_delayed_memory = map_dbl(very_delayed_memory, sum, na.rm=T))

mem3 = mem3 %&gt;%
  group_by(proid) %&gt;%
  filter(very_delayed_memory == max(very_delayed_memory)) %&gt;%
  filter(row_number() == 1 ) %&gt;% 
  select(-very_delayed_recall, -variable, -newid) 

data = full_join(data, mem3)</code></pre>
<p>Participants remember on average NA words correctly <span class="math inline">\((SD = NA)\)</span>.</p>
</div>
<div id="correlations" class="section level4" number="0.7.2.4">
<h4><span class="header-section-number">0.7.2.4</span> Correlations</h4>
<p>Figure <a href="#fig:memory-dist">7</a> displays the univariate and bivariate distributions of the memory scores and the bivariate correlations. In general, there was good spread in the immediate recall and delayed (10 minute) recall variables. Few participants remembered any of the words after two weeks.</p>
<pre class="r"><code>data %&gt;% 
  select(matches(&quot;memory$&quot;)) %&gt;% 
  corr.test</code></pre>
<pre><code>## Call:corr.test(x = .)
## Correlation matrix 
##                     memory delayed_memory very_delayed_memory
## memory                1.00           0.81                0.38
## delayed_memory        0.81           1.00                0.46
## very_delayed_memory   0.38           0.46                1.00
## Sample Size 
##                     memory delayed_memory very_delayed_memory
## memory                 974            974                 883
## delayed_memory         974            974                 883
## very_delayed_memory    883            883                 883
## Probability values (Entries above the diagonal are adjusted for multiple tests.) 
##                     memory delayed_memory very_delayed_memory
## memory                   0              0                   0
## delayed_memory           0              0                   0
## very_delayed_memory      0              0                   0
## 
##  To see confidence intervals of the correlations, print with the short=FALSE option</code></pre>
<div class="figure"><span style="display:block;" id="fig:memory-dist"></span>
<img src="1-cleaning_files/figure-html/memory-dist-1.png" alt="Distributions of memory scores across booth time points." width="672" />
<p class="caption">
Figure 7: Distributions of memory scores across booth time points.
</p>
</div>
</div>
</div>
<div id="change-labels-of-device-variable" class="section level3" number="0.7.3">
<h3><span class="header-section-number">0.7.3</span> Change labels of device variable</h3>
<p>Longer labels were provided to participants for clarity. However, we will use shorter labels in our analyses and figures.</p>
<pre class="r"><code>data = data %&gt;% 
  mutate(devicetype = factor(
    devicetype,
    levels = c(&quot;Desktop or laptop computer&quot;, &quot;Mobile&quot;, 
               &quot;Tablet (for example, iPad, Galaxy Tablet, Amazon Fire, etc.)&quot;), 
    labels = c(&quot;Computer&quot;, &quot;Mobile&quot;, &quot;Tablet&quot;)
  ))</code></pre>
</div>
<div id="reorder-demographic-categories" class="section level3" number="0.7.4">
<h3><span class="header-section-number">0.7.4</span> Reorder demographic categories</h3>
<p>We set the order of ordinal demographic variables, which helps generate more interpretable figures and tables.</p>
<pre class="r"><code>data = data %&gt;% 
  mutate(edu = factor(edu, 
                      levels = c(
                        &quot;Less than 12 years&quot;,
                        &quot;High school graduate/GED&quot;,
                        &quot;Currently in college/university&quot;,
                        &quot;Some college/university, but did not graduate&quot;,
                        &quot;Associate degree (2 year)&quot;,
                        &quot;College/university degree (4 year)&quot;,
                        &quot;Currently in graduate or professional school&quot;,
                        &quot;Graduate or professional school degree&quot;))) %&gt;% 
  mutate(hhinc = str_remove(hhinc, &quot; a year&quot;),
         hhinc = str_replace_all(hhinc, &quot;,000&quot;, &quot;K&quot;),
         hhinc = str_replace_all(hhinc, &quot; to &quot;, &quot;-&quot;),
         hhinc = str_replace_all(hhinc, &quot;less than&quot;, &quot;&lt;&quot;),
         hhinc = str_replace_all(hhinc, &quot;more than&quot;, &quot;&gt;&quot;))%&gt;% 
  mutate(hhinc = factor(hhinc,
                        levels = c(
                          &quot;&lt; $20,000&quot;,
                          &quot;$20K-$40K&quot;,
                          &quot;$40K-$60K&quot;,
                          &quot;$60K-$80K&quot;,
                          &quot;$80K-$100K&quot;,
                          &quot;$100K-$120K&quot;,
                          &quot;$120K-$150K&quot;,
                          &quot;$150K-$200K&quot;,
                          &quot;$200K-$250K&quot;,
                          &quot;$250K-$350K&quot;,
                          &quot;$350K-$500K&quot;,
                          &quot;&gt;$500K&quot;
                        )))</code></pre>
</div>
<div id="long-form-dataset" class="section level3" number="0.7.5">
<h3><span class="header-section-number">0.7.5</span> Long-form dataset</h3>
<p>We need one dataset that contains the responses to and timing of the personality items in long form. This will be used for nearly all the statistical models, which will nest items within person. To create this, we first select the responses to the items of different formats. For this set of analyses, we use data collected in both Block 1 and Block 2 – that is, each participant saw the same format for every item during Block 1, but a random format for each item in Block 2.</p>
<p>These variable names have one of four formats: <code>[trait]_[abcd]</code> (for example, <code>talkative_a</code>), <code>[trait]_[abcd]_2</code> (for example, <code>talkative_a_2</code>), <code>[trait]_[abcd]_3</code> (e.g., <code>talkative_a_3</code>), or <code>[trait]_[abcd]_3i</code> (e.g., <code>talkative_a_3i</code>). We search for these items using regular expressions.</p>
<pre class="r"><code>item_responses = str_subset(
  names(data),
  &quot;^([[:alpha:]])+_[abcd](_2)?(_3)?(i)?$&quot;
)</code></pre>
<p>Similarly, we’ll need to know how long it took participants to respond to these items. These variable names have one of four formats listed above followed by the string <code>page_submit</code>. We search for these items using regular expressions.</p>
<pre class="r"><code>item_timing = str_subset(
  names(data), 
  &quot;t_([[:alpha:]])+_[abcd](_2)?(_3)?(i)?_page_submit$&quot;)</code></pre>
<p>We extract just the participant IDs, delayed memory, and these variables.</p>
<pre class="r"><code>items_df = data %&gt;% 
  select(proid, condition, time2, 
         memory, delayed_memory, very_delayed_memory,
         devicetype, 
         all_of(item_responses), all_of(item_timing))</code></pre>
<p>Next we reshape these data into long form. This requires several steps. We’ll need to identify whether each value is a response or timing; we can use the presence of the string <code>t_</code> for this. Next, we’ll identify the block based on whether the string contains <code>_2</code> or <code>_3</code>. We also identify whether it ends with <code>i</code>, indicating the item in block 3 started with “I”. Then, we identify the condition based on which letter (<code>a</code>, <code>b</code>, <code>c</code>, or <code>d</code>) follows an underscore. Throughout, we’ll strip the item string of extraneous information until we’re left with only the adjective assessed. Finally, we’ll use spread to create separate columns for the response and the timing variables.</p>
<pre class="r"><code>items_df = items_df %&gt;%
  gather(item, value, all_of(item_responses), all_of(item_timing)) %&gt;%
  filter(!is.na(value)) %&gt;% 
  # identify whether timing or response
  mutate(variable = ifelse(str_detect(item, &quot;^t_&quot;), &quot;timing&quot;, &quot;response&quot;),
         item = str_remove(item, &quot;^t_&quot;),
         item = str_remove(item, &quot;_page_submit$&quot;)) %&gt;% 
  #identify block
  mutate(
    block = case_when(
      str_detect(item, &quot;_2&quot;) ~ &quot;2&quot;, 
      str_detect(item, &quot;_3&quot;) ~ &quot;3&quot;, 
      TRUE ~ &quot;1&quot;),
    item = str_remove(item, &quot;_[23]&quot;)) %&gt;% 
  # identify presence of &quot;I&quot;
  mutate(i = case_when(
    str_detect(item, &quot;i$&quot;) ~ &quot;Present&quot;,
    TRUE ~ &quot;Absent&quot;),
    item = str_remove(item, &quot;i$&quot;)) %&gt;% 
  separate(item, into = c(&quot;item&quot;, &quot;format&quot;)) %&gt;%
  spread(variable, value)</code></pre>
<div id="remove-human-and-asleep" class="section level4" number="0.7.5.1">
<h4><span class="header-section-number">0.7.5.1</span> Remove ‘human’ and ‘asleep’</h4>
<p>We also remove responses to the adjectives “human” and “asleep”, as these are not personality items per-se and included for the purpose of attention checks.</p>
<pre class="r"><code>items_df = items_df %&gt;% 
  filter(item != &quot;human&quot;) %&gt;% 
  filter(item != &quot;asleep&quot;)</code></pre>
</div>
<div id="label-formatting-conditions" class="section level4" number="0.7.5.2">
<h4><span class="header-section-number">0.7.5.2</span> Label formatting conditions</h4>
<p>We give labels to the formats, to clarify interpretations and aid table and figure construction.</p>
<pre class="r"><code>items_df$format = as.factor(items_df$format)
items_df$format = relevel(items_df$format, ref = &quot;a&quot;) 
items_df$format = factor(items_df$format,
                               levels = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;),
                               labels = c(&quot;Adjective\nOnly&quot;, &quot;Am\nAdjective&quot;, &quot;Tend to be\nAdjective&quot;, &quot;Am someone\nwho tends to be\nAdjective&quot;))</code></pre>
</div>
<div id="identify-big-five-mini-markers" class="section level4" number="0.7.5.3">
<h4><span class="header-section-number">0.7.5.3</span> Identify Big Five mini markers</h4>
<p>Big Five Mini Markers (BF-MM) are used only for the yea-saying analyses. We identify these adjectives here so that we can appropriately filter them in or out at each stage of analysis.</p>
<pre class="r"><code>bfmm = c(&quot;quiet&quot;, &quot;unsympathetic&quot;, &quot;relaxed&quot;, &quot;uncreative&quot;, 
         &quot;shy&quot;, &quot;cold&quot;, &quot;unintellectual&quot;)</code></pre>
</div>
<div id="transform-seconds" class="section level4" number="0.7.5.4">
<h4><span class="header-section-number">0.7.5.4</span> Transform seconds</h4>
<p>The variable <code>seconds</code> appears to have a very severe right skew (see Figure <a href="#fig:1-cleaning-95">8</a>). We log-transform this variable for later analyses.</p>
<pre class="r"><code>items_df = items_df %&gt;% 
  mutate(seconds_log = log(timing))

range(items_df$timing, na.rm=T)</code></pre>
<pre><code>## [1]   0.000 751.823</code></pre>
<pre class="r"><code>range(items_df$seconds_log, na.rm=T)</code></pre>
<pre><code>## [1]     -Inf 6.622501</code></pre>
<div class="figure"><span style="display:block;" id="fig:1-cleaning-95"></span>
<img src="1-cleaning_files/figure-html/1-cleaning-95-1.png" alt="Distribution of seconds, raw and transformed." width="672" />
<p class="caption">
Figure 8: Distribution of seconds, raw and transformed.
</p>
</div>
</div>
</div>
</div>
<div id="enjoyment" class="section level2" number="0.8">
<h2><span class="header-section-number">0.8</span> Enjoyment</h2>
<p>Finally, in the first wave of data collection, we poll participants about their enjoyment of the study and experience of taking the survey. We extract those columns, along with the condition assigned in Block 1, for later analyses.</p>
<pre class="r"><code>enjoy_df = data_t1 %&gt;% 
  select(proid, condition, devicetype, enjoy_responding, well_designed_study) %&gt;% 
  # convert responses to numeric
  mutate(
    format = tolower(condition),
    format = factor(format,
                    levels = c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;),
                    labels = c(&quot;Adjective\nOnly&quot;, 
                               &quot;Am\nAdjective&quot;, 
                               &quot;Tend to be\nAdjective&quot;, 
                               &quot;Am someone\nwho tends to be\nAdjective&quot;)),
    across(
      c(enjoy_responding, well_designed_study),
      ~case_when(
        . == &quot;Very inaccurate&quot;       ~ 1,
        . == &quot;Moderately inaccurate&quot; ~ 2,
        . == &quot;Slightly inaccurate&quot;   ~ 3,
        . == &quot;Slightly accurate&quot;     ~ 4,
        . == &quot;Moderately accurate&quot;   ~ 5,
        . == &quot;Very accurate&quot;         ~ 6,
        TRUE ~ NA_real_
      )
    )
  ) %&gt;% 
  filter(proid %in% items_df$proid)</code></pre>
</div>
<div id="save-files" class="section level2" number="0.9">
<h2><span class="header-section-number">0.9</span> Save files</h2>
<pre class="r"><code># check if folder exists. if not create it
if (!file.exists(here(&quot;objects/&quot;))){
    dir.create(here(&quot;objects/&quot;))
}
save(reverse, file = here(&quot;objects/reverse_vector.Rds&quot;))
save(bfmm, file = here(&quot;objects/bfmm.Rds&quot;))
save(data, file = here(&quot;objects/cleaned_data.Rds&quot;))
save(items_df, file = here(&quot;objects/items_df.Rds&quot;))
save(enjoy_df, file = here(&quot;objects/enjoy_df.Rds&quot;))</code></pre>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
